<?xml version="1.0" encoding="UTF-8"?>
<jmeterTestPlan version="1.2" properties="5.0" jmeter="5.4.3">
  <hashTree>
    <TestPlan guiclass="TestPlanGui" testclass="TestPlan" testname="Test Plan" enabled="true">
      <stringProp name="TestPlan.comments"></stringProp>
      <boolProp name="TestPlan.functional_mode">false</boolProp>
      <boolProp name="TestPlan.tearDown_on_shutdown">true</boolProp>
      <boolProp name="TestPlan.serialize_threadgroups">false</boolProp>
      <elementProp name="TestPlan.user_defined_variables" elementType="Arguments" guiclass="ArgumentsPanel" testclass="Arguments" testname="User Defined Variables" enabled="true">
        <collectionProp name="Arguments.arguments"/>
      </elementProp>
      <stringProp name="TestPlan.user_define_classpath"></stringProp>
    </TestPlan>
    <hashTree>
      <Arguments guiclass="ArgumentsPanel" testclass="Arguments" testname="User Defined Variables" enabled="true">
        <collectionProp name="Arguments.arguments">
          <elementProp name="tenant" elementType="Argument">
            <stringProp name="Argument.name">tenant</stringProp>
            <stringProp name="Argument.value">1146ddfb-fe47-4aac-b564-7f80b31008de</stringProp>
            <stringProp name="Argument.metadata">=</stringProp>
          </elementProp>
          <elementProp name="URL" elementType="Argument">
            <stringProp name="Argument.name">URL</stringProp>
            <stringProp name="Argument.value">https://perf.np-0000197.npause1.bakerhughes.com</stringProp>
            <stringProp name="Argument.metadata">=</stringProp>
          </elementProp>
          <elementProp name="username" elementType="Argument">
            <stringProp name="Argument.name">username</stringProp>
            <stringProp name="Argument.value">s1e-realm-admin</stringProp>
            <stringProp name="Argument.metadata">=</stringProp>
          </elementProp>
          <elementProp name="password" elementType="Argument">
            <stringProp name="Argument.name">password</stringProp>
            <stringProp name="Argument.value">Test@123</stringProp>
            <stringProp name="Argument.metadata">=</stringProp>
          </elementProp>
          <elementProp name="client_id" elementType="Argument">
            <stringProp name="Argument.name">client_id</stringProp>
            <stringProp name="Argument.value">app-timeseries-fdn-svc</stringProp>
            <stringProp name="Argument.metadata">=</stringProp>
          </elementProp>
          <elementProp name="grant_type" elementType="Argument">
            <stringProp name="Argument.name">grant_type</stringProp>
            <stringProp name="Argument.value">password</stringProp>
            <stringProp name="Argument.metadata">=</stringProp>
          </elementProp>
          <elementProp name="client_secret" elementType="Argument">
            <stringProp name="Argument.name">client_secret</stringProp>
            <stringProp name="Argument.value">${__P(client_secret,hdLPJDxN1539MnsVe7LqfnYf7TWnhSTAJp8s)}</stringProp>
            <stringProp name="Argument.metadata">=</stringProp>
          </elementProp>
          <elementProp name="AuthURL" elementType="Argument">
            <stringProp name="Argument.name">AuthURL</stringProp>
            <stringProp name="Argument.value">${__P(AuthURL,auth-perf.np-0000197.npause1.bakerhughes.com)}</stringProp>
            <stringProp name="Argument.metadata">=</stringProp>
          </elementProp>
          <elementProp name="tenantDriverCsvPath" elementType="Argument">
            <stringProp name="Argument.name">tenantDriverCsvPath</stringProp>
            <stringProp name="Argument.value">C:/AllJmeterScriptsBackup/AllJmeterScriptsBackup/refactoredCsvRead_april25/refactored/tenantConfig2.csv</stringProp>
            <stringProp name="Argument.metadata">=</stringProp>
          </elementProp>
          <elementProp name="globalInitialTimeMillisVar" elementType="Argument">
            <stringProp name="Argument.name">globalInitialTimeMillisVar</stringProp>
            <stringProp name="Argument.value"></stringProp>
            <stringProp name="Argument.metadata">=</stringProp>
          </elementProp>
        </collectionProp>
      </Arguments>
      <hashTree/>
      <ThreadGroup guiclass="ThreadGroupGui" testclass="ThreadGroup" testname="Thread Group" enabled="false">
        <stringProp name="ThreadGroup.on_sample_error">continue</stringProp>
        <elementProp name="ThreadGroup.main_controller" elementType="LoopController" guiclass="LoopControlPanel" testclass="LoopController" testname="Loop Controller" enabled="true">
          <boolProp name="LoopController.continue_forever">false</boolProp>
          <stringProp name="LoopController.loops">1</stringProp>
        </elementProp>
        <stringProp name="ThreadGroup.num_threads">1</stringProp>
        <stringProp name="ThreadGroup.ramp_time">1</stringProp>
        <boolProp name="ThreadGroup.scheduler">false</boolProp>
        <stringProp name="ThreadGroup.duration"></stringProp>
        <stringProp name="ThreadGroup.delay"></stringProp>
        <boolProp name="ThreadGroup.same_user_on_next_iteration">false</boolProp>
      </ThreadGroup>
      <hashTree>
        <CSVDataSet guiclass="TestBeanGUI" testclass="CSVDataSet" testname="Extract Runtime Configuration" enabled="true">
          <stringProp name="delimiter">,</stringProp>
          <stringProp name="fileEncoding"></stringProp>
          <stringProp name="filename">${tenantDriverCsvPath}</stringProp>
          <boolProp name="ignoreFirstLine">true</boolProp>
          <boolProp name="quotedData">false</boolProp>
          <boolProp name="recycle">false</boolProp>
          <stringProp name="shareMode">shareMode.all</stringProp>
          <boolProp name="stopThread">true</boolProp>
          <stringProp name="variableNames">Tenant_Id,Start_Id,End_Id</stringProp>
        </CSVDataSet>
        <hashTree/>
        <JSR223Sampler guiclass="TestBeanGUI" testclass="JSR223Sampler" testname="Extract Tag Ids" enabled="true">
          <stringProp name="cacheKey">false</stringProp>
          <stringProp name="filename"></stringProp>
          <stringProp name="parameters"></stringProp>
          <stringProp name="script">import groovy.json.*

tenantSpecTagsFile = new File(String.valueOf(vars.get(&quot;parentDirTenantTagsCsv&quot;))+vars.get(&quot;Tenant_Id&quot;)+&quot;.csv&quot;);

Integer startTagRow = Integer.valueOf(vars.get(&quot;Start_Id&quot;))+1;
Integer endTagRow = Integer.valueOf(vars.get(&quot;End_Id&quot;))+1;

def lineList = []
String[] tagList;
def tagsForRequestBody = [];
def S1_Ids_Raw = []
def Pi_Ids_Raw = []
def Pg_Ids_Raw = []
def S1Group_Ids = []

def S1_Ids_Summary = []
def Pi_Ids_Summary = []
def Pg_Ids_Summary = []

class FileHelper {
    static eachLineInRange(File file, IntRange lineRange, Closure closure) {
        file.withReader { r-&gt;
            def line
            for(; (line = r.readLine()) != null;) {
                def lineNo = r.lineNumber
                if(lineNo &lt; lineRange.from) continue
                if(lineNo &gt; lineRange.to) break
                closure.call(line, lineNo)
            }
        }
    }
}

	
use(FileHelper) {

tenantSpecTagsFile.eachLineInRange(startTagRow..endTagRow){line, lineNo -&gt;
def values = line.split(&apos;,&apos;)

Pg_Ids_Raw.add(&quot;\&quot;&quot;+values[1]+&quot;\&quot;&quot;)
Pi_Ids_Raw.add(&quot;\&quot;&quot;+values[2]+&quot;\&quot;&quot;)
S1_Ids_Raw.add(&quot;\&quot;&quot;+values[3]+&quot;\&quot;&quot;)
S1Group_Ids.add(&quot;\&quot;&quot;+values[4]+&quot;\&quot;&quot;)
   }

}

for(int i =0;i&lt;24;++i){
	 S1_Ids_Summary.add(S1_Ids_Raw[i]);
	 Pi_Ids_Summary.add(Pi_Ids_Raw[i]);
	 Pg_Ids_Summary.add(Pg_Ids_Raw[i]);
}

vars.put(&quot;Pg_Tags_Raw&quot;,String.valueOf(Pg_Ids_Raw));
vars.put(&quot;Pi_Tags_Raw&quot;,String.valueOf(Pi_Ids_Raw));
vars.put(&quot;S1_Tags_Raw&quot;,String.valueOf(S1_Ids_Raw));
vars.put(&quot;S1GroupTags&quot;,String.valueOf(S1Group_Ids[0]));
vars.put(&quot;S1_Tags_Summary&quot;,String.valueOf(S1_Ids_Summary));
vars.put(&quot;Pi_Tags_Summary&quot;,String.valueOf(Pi_Ids_Summary));
vars.put(&quot;Pg_Tags_Summary&quot;,String.valueOf(Pg_Ids_Summary));

</stringProp>
          <stringProp name="scriptLanguage">groovy</stringProp>
        </JSR223Sampler>
        <hashTree/>
        <JSR223Sampler guiclass="TestBeanGUI" testclass="JSR223Sampler" testname="Extract Timestsamps" enabled="true">
          <stringProp name="cacheKey">true</stringProp>
          <stringProp name="filename"></stringProp>
          <stringProp name="parameters"></stringProp>
          <stringProp name="script">import groovy.json.*

//for raw take current time
Calendar curRawTime = Calendar.getInstance();
curRawTime.setTimeInMillis(curRawTime.getTimeInMillis()); 

// for summary 4 months
Calendar curSummaryTime = Calendar.getInstance();
curSummaryTime.setTimeInMillis(curSummaryTime.getTimeInMillis()); 

//for raw minus 11 minutes
curRawTime.add(Calendar.MINUTE, -11);

//for summary minus 4 months
curSummaryTime.add(Calendar.MONTH, -4);

//for raw convert it to ticks
//that is the start time
TimeZone curRawTimeZone = curRawTime.getTimeZone();
int offsetRawFromUTC = curRawTimeZone.getOffset(curRawTime.getTimeInMillis());

curRawTime.add(Calendar.MILLISECOND, offsetRawFromUTC);

Long rawCallStartTimeStamp = (curRawTime.getTimeInMillis() * 10000) + 621355968000000000;
vars.put(&quot;rawCallStartTimeStampVar&quot;,String.valueOf(rawCallStartTimeStamp));

//for summary 4 months
//convert it to ticks
//that is the start time
TimeZone curSummaryTimeZone = curSummaryTime.getTimeZone();
int offsetSummaryFromUTC = curSummaryTimeZone.getOffset(curSummaryTime.getTimeInMillis());

curSummaryTime.add(Calendar.MILLISECOND, offsetSummaryFromUTC);

Long summaryCallStartTimeStamp = (curSummaryTime.getTimeInMillis() * 10000) + 621355968000000000;
vars.put(&quot;summaryCallStartTimeStampVar&quot;,String.valueOf(summaryCallStartTimeStamp));

//for raw then add 10 minutes to (current time - 11 mins)
//convert it to ticks
//that is the end time
curRawTime.add(Calendar.MINUTE, 10);

Long rawEndTimeStamp = (curRawTime.getTimeInMillis() * 10000) + 621355968000000000;
vars.put(&quot;rawEndTimeStampVar&quot;,String.valueOf(rawEndTimeStamp));

//then for summary add 4 months to (current time - 4 MONTHS)
//convert it to ticks
//that is the end time
curSummaryTime.add(Calendar.MONTH, 4);

Long summaryEndTimeStamp = (curSummaryTime.getTimeInMillis() * 10000) + 621355968000000000;
vars.put(&quot;summaryEndTimeStampVar&quot;,String.valueOf(summaryEndTimeStamp));

//count the num of tags there [by (diff of startid and endid) + 1]
int numOfTags = Integer.valueOf(vars.get(&quot;End_Id&quot;)) - Integer.valueOf(vars.get(&quot;Start_Id&quot;)) + 1;

//run the loop that many times and create an array with starttimestamp that many times
def listOfRawStartTimes = [];
for (int i=1;i&lt;=numOfTags;++i){
	listOfRawStartTimes.add(rawCallStartTimeStamp);
}

vars.put(&quot;listOfRawStartTimesVar&quot;,String.valueOf(listOfRawStartTimes));

</stringProp>
          <stringProp name="scriptLanguage">groovy</stringProp>
        </JSR223Sampler>
        <hashTree/>
        <JSR223Sampler guiclass="TestBeanGUI" testclass="JSR223Sampler" testname="Fetch Raw PG Api Body" enabled="true">
          <stringProp name="cacheKey">true</stringProp>
          <stringProp name="filename"></stringProp>
          <stringProp name="parameters"></stringProp>
          <stringProp name="script">import groovy.json.*

String groupIdStr = &quot;&quot;;

String fetchPgRawCallBody = &quot;{&quot;+groupIdStr+&quot;\&quot;tagIds\&quot;:&quot;+String.valueOf(vars.get(&quot;Pg_Tags_Raw&quot;))+&quot;,\&quot;startTimes\&quot;:&quot;+String.valueOf(vars.get(&quot;listOfRawStartTimesVar&quot;))+&quot;,\&quot;endTime\&quot;:&quot;+String.valueOf(vars.get(&quot;rawEndTimeStampVar&quot;))+&quot;,\&quot;resolution\&quot;:20,\&quot;TriggerType\&quot;: \&quot;Trend\&quot;,\&quot;maxNumberOfSamplesPerTag\&quot;: 30,\&quot;requestedStatusBits\&quot;: 0,\&quot;associatedTagIds\&quot;: {}&quot;+&quot;}&quot;;

vars.put(&quot;Payload_FetchPgRaw&quot;, fetchPgRawCallBody);
</stringProp>
          <stringProp name="scriptLanguage">groovy</stringProp>
        </JSR223Sampler>
        <hashTree/>
        <JSR223Sampler guiclass="TestBeanGUI" testclass="JSR223Sampler" testname="Fetch Raw Pi Api Body" enabled="true">
          <stringProp name="cacheKey">true</stringProp>
          <stringProp name="filename"></stringProp>
          <stringProp name="parameters"></stringProp>
          <stringProp name="script">import groovy.json.*

String groupIdStr = &quot;&quot;;

String fetchPiRawCallBody = &quot;{&quot;+groupIdStr+&quot;\&quot;tagIds\&quot;:&quot;+String.valueOf(vars.get(&quot;Pi_Tags_Raw&quot;))+&quot;,\&quot;startTimes\&quot;:&quot;+String.valueOf(vars.get(&quot;listOfRawStartTimesVar&quot;))+&quot;,\&quot;endTime\&quot;:&quot;+String.valueOf(vars.get(&quot;rawEndTimeStampVar&quot;))+&quot;,\&quot;resolution\&quot;:20,\&quot;TriggerType\&quot;: \&quot;Trend\&quot;,\&quot;maxNumberOfSamplesPerTag\&quot;: 30,\&quot;requestedStatusBits\&quot;: 0,\&quot;associatedTagIds\&quot;: {}&quot;+&quot;}&quot;;

vars.put(&quot;Payload_FetchPiRaw&quot;, fetchPiRawCallBody);
</stringProp>
          <stringProp name="scriptLanguage">groovy</stringProp>
        </JSR223Sampler>
        <hashTree/>
        <JSR223Sampler guiclass="TestBeanGUI" testclass="JSR223Sampler" testname="Fetch Raw S1 Api Body" enabled="true">
          <stringProp name="cacheKey">true</stringProp>
          <stringProp name="filename"></stringProp>
          <stringProp name="parameters"></stringProp>
          <stringProp name="script">import groovy.json.*

String groupIdStr = &quot;\&quot;groupId\&quot;:&quot;+String.valueOf(vars.get(&quot;S1GroupTags&quot;))+&quot;,&quot;;

String fetchS1RawCallBody = &quot;{&quot;+groupIdStr+&quot;\&quot;tagIds\&quot;:&quot;+String.valueOf(vars.get(&quot;S1_Tags_Raw&quot;))+&quot;,\&quot;startTimes\&quot;:&quot;+String.valueOf(vars.get(&quot;listOfRawStartTimesVar&quot;))+&quot;,\&quot;endTime\&quot;:&quot;+String.valueOf(vars.get(&quot;rawEndTimeStampVar&quot;))+&quot;,\&quot;resolution\&quot;:20,\&quot;TriggerType\&quot;: \&quot;Trend\&quot;,\&quot;maxNumberOfSamplesPerTag\&quot;: 30,\&quot;requestedStatusBits\&quot;: 0,\&quot;associatedTagIds\&quot;: {}&quot;+&quot;}&quot;;

vars.put(&quot;Payload_FetchS1Raw&quot;, fetchS1RawCallBody);
</stringProp>
          <stringProp name="scriptLanguage">groovy</stringProp>
        </JSR223Sampler>
        <hashTree/>
        <JSR223Sampler guiclass="TestBeanGUI" testclass="JSR223Sampler" testname="Fetch Summary PG Api Body" enabled="true">
          <stringProp name="cacheKey">true</stringProp>
          <stringProp name="filename"></stringProp>
          <stringProp name="parameters"></stringProp>
          <stringProp name="script">import groovy.json.*

String groupIdStr = &quot;&quot;;

// take 24 wala variable array
String fetchPgSummaryCallBody = &quot;{&quot;+groupIdStr+&quot;\&quot;tagIds\&quot;:&quot;+String.valueOf(vars.get(&quot;Pg_Tags_Summary&quot;))+&quot;,\&quot;startTime\&quot;:&quot;+String.valueOf(vars.get(&quot;summaryCallStartTimeStampVar&quot;))+&quot;,\&quot;endTime\&quot;:&quot;+String.valueOf(vars.get(&quot;summaryEndTimeStampVar&quot;))+&quot;,\&quot;summaryTypes\&quot;:[\&quot;MinValue\&quot;,\&quot;MaxValue\&quot;],\&quot;triggerTypeProportions\&quot;:{\&quot;Trend\&quot;:\&quot;60\&quot;,\&quot;Alarm\&quot;:\&quot;30\&quot;,\&quot;Transient\&quot;:\&quot;10\&quot;},\&quot;maxNumberOfSamplesPerTag\&quot;: 30,\&quot;requestedStatusBits\&quot;:0,\&quot;associatedTagIds\&quot;:{}&quot;+&quot;}&quot;;

vars.put(&quot;Payload_FetchPgSummary&quot;, fetchPgSummaryCallBody);
</stringProp>
          <stringProp name="scriptLanguage">groovy</stringProp>
        </JSR223Sampler>
        <hashTree/>
        <JSR223Sampler guiclass="TestBeanGUI" testclass="JSR223Sampler" testname="Fetch Summary Pi Api Body" enabled="true">
          <stringProp name="cacheKey">true</stringProp>
          <stringProp name="filename"></stringProp>
          <stringProp name="parameters"></stringProp>
          <stringProp name="script">import groovy.json.*

String groupIdStr = &quot;&quot;;

String fetchPiSummaryCallBody = &quot;{&quot;+groupIdStr+&quot;\&quot;tagIds\&quot;:&quot;+String.valueOf(vars.get(&quot;Pi_Tags_Summary&quot;))+&quot;,\&quot;startTime\&quot;:&quot;+String.valueOf(vars.get(&quot;summaryCallStartTimeStampVar&quot;))+&quot;,\&quot;endTime\&quot;:&quot;+String.valueOf(vars.get(&quot;summaryEndTimeStampVar&quot;))+&quot;,\&quot;summaryTypes\&quot;:[\&quot;MinValue\&quot;,\&quot;MaxValue\&quot;],\&quot;triggerTypeProportions\&quot;:{\&quot;Trend\&quot;:\&quot;60\&quot;,\&quot;Alarm\&quot;:\&quot;30\&quot;,\&quot;Transient\&quot;:\&quot;10\&quot;},\&quot;maxNumberOfSamplesPerTag\&quot;: 30,\&quot;requestedStatusBits\&quot;:0,\&quot;associatedTagIds\&quot;:{}&quot;+&quot;}&quot;;

vars.put(&quot;Payload_FetchPiSummary&quot;, fetchPiSummaryCallBody);
</stringProp>
          <stringProp name="scriptLanguage">groovy</stringProp>
        </JSR223Sampler>
        <hashTree/>
        <JSR223Sampler guiclass="TestBeanGUI" testclass="JSR223Sampler" testname="Fetch Summary S1 Api Body" enabled="true">
          <stringProp name="cacheKey">true</stringProp>
          <stringProp name="filename"></stringProp>
          <stringProp name="parameters"></stringProp>
          <stringProp name="script">import groovy.json.*

String groupIdStr = &quot;\&quot;groupId\&quot;:&quot;+String.valueOf(vars.get(&quot;S1GroupTags&quot;))+&quot;,&quot;;

String fetchS1SummaryCallBody = &quot;{&quot;+groupIdStr+&quot;\&quot;tagIds\&quot;:&quot;+String.valueOf(vars.get(&quot;S1_Tags_Summary&quot;))+&quot;,\&quot;startTime\&quot;:&quot;+String.valueOf(vars.get(&quot;summaryCallStartTimeStampVar&quot;))+&quot;,\&quot;endTime\&quot;:&quot;+String.valueOf(vars.get(&quot;summaryEndTimeStampVar&quot;))+&quot;,\&quot;summaryTypes\&quot;:[\&quot;MinValue\&quot;,\&quot;MaxValue\&quot;],\&quot;triggerTypeProportions\&quot;:{\&quot;Trend\&quot;:\&quot;60\&quot;,\&quot;Alarm\&quot;:\&quot;30\&quot;,\&quot;Transient\&quot;:\&quot;10\&quot;},\&quot;maxNumberOfSamplesPerTag\&quot;: 30,\&quot;requestedStatusBits\&quot;:0,\&quot;associatedTagIds\&quot;:{}&quot;+&quot;}&quot;;

vars.put(&quot;Payload_FetchS1Summary&quot;, fetchS1SummaryCallBody);
</stringProp>
          <stringProp name="scriptLanguage">groovy</stringProp>
        </JSR223Sampler>
        <hashTree/>
        <JSR223Sampler guiclass="TestBeanGUI" testclass="JSR223Sampler" testname="Set PG Offline Tags Api Body" enabled="true">
          <stringProp name="cacheKey">true</stringProp>
          <stringProp name="filename"></stringProp>
          <stringProp name="parameters"></stringProp>
          <stringProp name="script">import groovy.json.*
import java.util.GregorianCalendar;
import java.util.Calendar;
import java.util.Date;
import java.util.Random;

Calendar setCal = Calendar.getInstance();

setCal.add(Calendar.MINUTE, -11);

randomValue = new Random();

BigInteger timeStamp = 0;
BigInteger startTimeStamp = 0;
BigInteger curStartTimeMillisLocVar = 0;
BigInteger curEndTimeMillisLocVar = 0;


BigInteger[] timeTickArray = new BigInteger[31];

timeTickArray[0] = (setCal.getTimeInMillis() * 10000) + 621355968000000000 - 26586006500000;

for (int i = 1;i&lt;31;++i)
{
	setCal.add(Calendar.SECOND, 20);
	timeTickArray[i] = (setCal.getTimeInMillis() * 10000) + 621355968000000000 - 26586006500000;
}


def String strOfflineBody = &quot;&quot;;

def String reqParametersStr = &apos;{&quot;collectionType&quot;: &quot;Offline&quot;,&quot;dataStream&quot;:&quot;Live&quot;,&quot;triggerType&quot;: &quot;Trend&quot;,&quot;sampleSets&quot;:[&apos;;

def String combSamplesStr = &quot;&quot;;

def String closingBracketStr = &quot;]}&quot;;


def Integer curGroupNum = ctx.getThreadGroup().getNumberOfThreads();
def String curGroupStr = String.valueOf(curGroupNum);

for(int j = 1;j&lt;=300;++j){

def ranInt = randomValue.nextInt(90);

samplesSetStr=&apos;{ &quot;tagId&quot;: &quot;RelTestPERF_AWS_5APR23_OfflineTag_&apos;+j+&apos;_G_&apos;+curGroupNum+&apos;&quot;, &quot;Samples&quot;: [{\&quot;value\&quot;:60.0,\&quot;dataStatus\&quot;:0,\&quot;nodeStatus\&quot;:0,\&quot;timeStamp\&quot;:&apos;+timeTickArray[0]+&apos;},{\&quot;value\&quot;:&apos;+String.valueOf(randomValue.nextInt(90))+&apos;,\&quot;dataStatus\&quot;:0,\&quot;nodeStatus\&quot;:0,\&quot;timeStamp\&quot;:&apos;+timeTickArray[1]+&apos;},{\&quot;value\&quot;:&apos;+String.valueOf(randomValue.nextInt(90))+&apos;,\&quot;dataStatus\&quot;:0,\&quot;nodeStatus\&quot;:0,\&quot;timeStamp\&quot;:&apos;+timeTickArray[2]+&apos;},{\&quot;value\&quot;:&apos;+String.valueOf(randomValue.nextInt(90))+&apos;,\&quot;dataStatus\&quot;:0,\&quot;nodeStatus\&quot;:0,\&quot;timeStamp\&quot;:&apos;+timeTickArray[3]+&apos;},{\&quot;value\&quot;:&apos;+String.valueOf(randomValue.nextInt(90))+&apos;,\&quot;dataStatus\&quot;:0,\&quot;nodeStatus\&quot;:0,\&quot;timeStamp\&quot;:&apos;+timeTickArray[4]+&apos;},{\&quot;value\&quot;:&apos;+String.valueOf(randomValue.nextInt(90))+&apos;,\&quot;dataStatus\&quot;:0,\&quot;nodeStatus\&quot;:0,\&quot;timeStamp\&quot;:&apos;+timeTickArray[5]+&apos;},{\&quot;value\&quot;:&apos;+String.valueOf(randomValue.nextInt(90))+&apos;,\&quot;dataStatus\&quot;:0,\&quot;nodeStatus\&quot;:0,\&quot;timeStamp\&quot;:&apos;+timeTickArray[6]+&apos;},{\&quot;value\&quot;:&apos;+String.valueOf(randomValue.nextInt(90))+&apos;,\&quot;dataStatus\&quot;:0,\&quot;nodeStatus\&quot;:0,\&quot;timeStamp\&quot;:&apos;+timeTickArray[7]+&apos;},{\&quot;value\&quot;:&apos;+String.valueOf(randomValue.nextInt(90))+&apos;,\&quot;dataStatus\&quot;:0,\&quot;nodeStatus\&quot;:0,\&quot;timeStamp\&quot;:&apos;+timeTickArray[8]+&apos;},{\&quot;value\&quot;:&apos;+String.valueOf(randomValue.nextInt(90))+&apos;,\&quot;dataStatus\&quot;:0,\&quot;nodeStatus\&quot;:0,\&quot;timeStamp\&quot;:&apos;+timeTickArray[9]+&apos;},{\&quot;value\&quot;:&apos;+String.valueOf(randomValue.nextInt(90))+&apos;,\&quot;dataStatus\&quot;:0,\&quot;nodeStatus\&quot;:0,\&quot;timeStamp\&quot;:&apos;+timeTickArray[10]+&apos;},{\&quot;value\&quot;:&apos;+String.valueOf(randomValue.nextInt(90))+&apos;,\&quot;dataStatus\&quot;:0,\&quot;nodeStatus\&quot;:0,\&quot;timeStamp\&quot;:&apos;+timeTickArray[11]+&apos;},{\&quot;value\&quot;:&apos;+String.valueOf(randomValue.nextInt(90))+&apos;,\&quot;dataStatus\&quot;:0,\&quot;nodeStatus\&quot;:0,\&quot;timeStamp\&quot;:&apos;+timeTickArray[12]+&apos;},{\&quot;value\&quot;:&apos;+String.valueOf(randomValue.nextInt(90))+&apos;,\&quot;dataStatus\&quot;:0,\&quot;nodeStatus\&quot;:0,\&quot;timeStamp\&quot;:&apos;+timeTickArray[13]+&apos;},{\&quot;value\&quot;:&apos;+String.valueOf(randomValue.nextInt(90))+&apos;,\&quot;dataStatus\&quot;:0,\&quot;nodeStatus\&quot;:0,\&quot;timeStamp\&quot;:&apos;+timeTickArray[14]+&apos;},{\&quot;value\&quot;:&apos;+String.valueOf(randomValue.nextInt(90))+&apos;,\&quot;dataStatus\&quot;:0,\&quot;nodeStatus\&quot;:0,\&quot;timeStamp\&quot;:&apos;+timeTickArray[15]+&apos;},{\&quot;value\&quot;:&apos;+String.valueOf(randomValue.nextInt(90))+&apos;,\&quot;dataStatus\&quot;:0,\&quot;nodeStatus\&quot;:0,\&quot;timeStamp\&quot;:&apos;+timeTickArray[16]+&apos;},{\&quot;value\&quot;:&apos;+String.valueOf(randomValue.nextInt(90))+&apos;,\&quot;dataStatus\&quot;:0,\&quot;nodeStatus\&quot;:0,\&quot;timeStamp\&quot;:&apos;+timeTickArray[17]+&apos;},{\&quot;value\&quot;:&apos;+String.valueOf(randomValue.nextInt(90))+&apos;,\&quot;dataStatus\&quot;:0,\&quot;nodeStatus\&quot;:0,\&quot;timeStamp\&quot;:&apos;+timeTickArray[18]+&apos;},{\&quot;value\&quot;:&apos;+String.valueOf(randomValue.nextInt(90))+&apos;,\&quot;dataStatus\&quot;:0,\&quot;nodeStatus\&quot;:0,\&quot;timeStamp\&quot;:&apos;+timeTickArray[19]+&apos;},{\&quot;value\&quot;:&apos;+String.valueOf(randomValue.nextInt(90))+&apos;,\&quot;dataStatus\&quot;:0,\&quot;nodeStatus\&quot;:0,\&quot;timeStamp\&quot;:&apos;+timeTickArray[20]+&apos;},{\&quot;value\&quot;:&apos;+String.valueOf(randomValue.nextInt(90))+&apos;,\&quot;dataStatus\&quot;:0,\&quot;nodeStatus\&quot;:0,\&quot;timeStamp\&quot;:&apos;+timeTickArray[21]+&apos;},{\&quot;value\&quot;:&apos;+String.valueOf(randomValue.nextInt(90))+&apos;,\&quot;dataStatus\&quot;:0,\&quot;nodeStatus\&quot;:0,\&quot;timeStamp\&quot;:&apos;+timeTickArray[22]+&apos;},{\&quot;value\&quot;:&apos;+String.valueOf(randomValue.nextInt(90))+&apos;,\&quot;dataStatus\&quot;:0,\&quot;nodeStatus\&quot;:0,\&quot;timeStamp\&quot;:&apos;+timeTickArray[23]+&apos;},{\&quot;value\&quot;:&apos;+String.valueOf(randomValue.nextInt(90))+&apos;,\&quot;dataStatus\&quot;:0,\&quot;nodeStatus\&quot;:0,\&quot;timeStamp\&quot;:&apos;+timeTickArray[24]+&apos;},{\&quot;value\&quot;:&apos;+String.valueOf(randomValue.nextInt(90))+&apos;,\&quot;dataStatus\&quot;:0,\&quot;nodeStatus\&quot;:0,\&quot;timeStamp\&quot;:&apos;+timeTickArray[25]+&apos;},{\&quot;value\&quot;:&apos;+String.valueOf(randomValue.nextInt(90))+&apos;,\&quot;dataStatus\&quot;:0,\&quot;nodeStatus\&quot;:0,\&quot;timeStamp\&quot;:&apos;+timeTickArray[26]+&apos;},{\&quot;value\&quot;:&apos;+String.valueOf(randomValue.nextInt(90))+&apos;,\&quot;dataStatus\&quot;:0,\&quot;nodeStatus\&quot;:0,\&quot;timeStamp\&quot;:&apos;+timeTickArray[27]+&apos;},{\&quot;value\&quot;:&apos;+String.valueOf(randomValue.nextInt(90))+&apos;,\&quot;dataStatus\&quot;:0,\&quot;nodeStatus\&quot;:0,\&quot;timeStamp\&quot;:&apos;+timeTickArray[28]+&apos;},{\&quot;value\&quot;:&apos;+String.valueOf(randomValue.nextInt(90))+&apos;,\&quot;dataStatus\&quot;:0,\&quot;nodeStatus\&quot;:0,\&quot;timeStamp\&quot;:&apos;+timeTickArray[29]+&apos;}], &quot;sampleType&quot;: &quot;StaticDataSample&quot;},&apos;;


combSamplesStr = combSamplesStr+samplesSetStr;

}

strOfflineBody = reqParametersStr+combSamplesStr+closingBracketStr;

vars.put(&quot;Payload_SetPGOfflineTags&quot;, strOfflineBody);
</stringProp>
          <stringProp name="scriptLanguage">groovy</stringProp>
        </JSR223Sampler>
        <hashTree/>
        <JSR223Sampler guiclass="TestBeanGUI" testclass="JSR223Sampler" testname="Set PG Online Tags Api Body" enabled="true">
          <stringProp name="cacheKey">true</stringProp>
          <stringProp name="filename"></stringProp>
          <stringProp name="parameters"></stringProp>
          <stringProp name="script">import groovy.json.*

import java.util.GregorianCalendar;
import java.util.Calendar;
import java.util.Date;

import java.util.Random;

Calendar setCal = Calendar.getInstance();

setCal.add(Calendar.MINUTE, -11);

randomValue = new Random();

BigInteger timeStamp = 0;
BigInteger startTimeStamp = 0;
BigInteger curStartTimeMillisLocVar = 0;
BigInteger curEndTimeMillisLocVar = 0;

BigInteger[] timeTickArray = new BigInteger[31];

timeTickArray[0] = (setCal.getTimeInMillis() * 10000) + 621355968000000000 - 26586006500000;

for (int i = 1;i&lt;31;++i)
{
	setCal.add(Calendar.SECOND, 20);
	timeTickArray[i] = (setCal.getTimeInMillis() * 10000) + 621355968000000000 - 26586006500000;
}


def String strOnlineBody = &quot;&quot;;

def String reqParametersStr = &apos;{&quot;collectionType&quot;: &quot;Online&quot;,&quot;dataStream&quot;:&quot;Live&quot;,&quot;triggerType&quot;: &quot;Trend&quot;,&quot;sampleSets&quot;:[&apos;;

def String combSamplesStr = &quot;&quot;;

def String sampleSetStr = &quot;&quot;;

def String closingBracketStr = &quot;]}&quot;;

def Integer curGroupNum = ctx.getThreadGroup().getNumberOfThreads();
def String curGroupStr = String.valueOf(curGroupNum);

for(int j = 1;j&lt;=300;++j){

def ranInt = randomValue.nextInt(90);

samplesSetStr=&apos;{ &quot;tagId&quot;: &quot;RelTestPERF_AWS_5APR23_OfflineTag_&apos;+j+&apos;_G_&apos;+curGroupNum+&apos;&quot;, &quot;Samples&quot;: [{\&quot;value\&quot;:60.0,\&quot;dataStatus\&quot;:0,\&quot;nodeStatus\&quot;:0,\&quot;timeStamp\&quot;:&apos;+timeTickArray[0]+&apos;},{\&quot;value\&quot;:&apos;+String.valueOf(randomValue.nextInt(90))+&apos;,\&quot;dataStatus\&quot;:0,\&quot;nodeStatus\&quot;:0,\&quot;timeStamp\&quot;:&apos;+timeTickArray[1]+&apos;},{\&quot;value\&quot;:&apos;+String.valueOf(randomValue.nextInt(90))+&apos;,\&quot;dataStatus\&quot;:0,\&quot;nodeStatus\&quot;:0,\&quot;timeStamp\&quot;:&apos;+timeTickArray[2]+&apos;},{\&quot;value\&quot;:&apos;+String.valueOf(randomValue.nextInt(90))+&apos;,\&quot;dataStatus\&quot;:0,\&quot;nodeStatus\&quot;:0,\&quot;timeStamp\&quot;:&apos;+timeTickArray[3]+&apos;},{\&quot;value\&quot;:&apos;+String.valueOf(randomValue.nextInt(90))+&apos;,\&quot;dataStatus\&quot;:0,\&quot;nodeStatus\&quot;:0,\&quot;timeStamp\&quot;:&apos;+timeTickArray[4]+&apos;},{\&quot;value\&quot;:&apos;+String.valueOf(randomValue.nextInt(90))+&apos;,\&quot;dataStatus\&quot;:0,\&quot;nodeStatus\&quot;:0,\&quot;timeStamp\&quot;:&apos;+timeTickArray[5]+&apos;},{\&quot;value\&quot;:&apos;+String.valueOf(randomValue.nextInt(90))+&apos;,\&quot;dataStatus\&quot;:0,\&quot;nodeStatus\&quot;:0,\&quot;timeStamp\&quot;:&apos;+timeTickArray[6]+&apos;},{\&quot;value\&quot;:&apos;+String.valueOf(randomValue.nextInt(90))+&apos;,\&quot;dataStatus\&quot;:0,\&quot;nodeStatus\&quot;:0,\&quot;timeStamp\&quot;:&apos;+timeTickArray[7]+&apos;},{\&quot;value\&quot;:&apos;+String.valueOf(randomValue.nextInt(90))+&apos;,\&quot;dataStatus\&quot;:0,\&quot;nodeStatus\&quot;:0,\&quot;timeStamp\&quot;:&apos;+timeTickArray[8]+&apos;},{\&quot;value\&quot;:&apos;+String.valueOf(randomValue.nextInt(90))+&apos;,\&quot;dataStatus\&quot;:0,\&quot;nodeStatus\&quot;:0,\&quot;timeStamp\&quot;:&apos;+timeTickArray[9]+&apos;},{\&quot;value\&quot;:&apos;+String.valueOf(randomValue.nextInt(90))+&apos;,\&quot;dataStatus\&quot;:0,\&quot;nodeStatus\&quot;:0,\&quot;timeStamp\&quot;:&apos;+timeTickArray[10]+&apos;},{\&quot;value\&quot;:&apos;+String.valueOf(randomValue.nextInt(90))+&apos;,\&quot;dataStatus\&quot;:0,\&quot;nodeStatus\&quot;:0,\&quot;timeStamp\&quot;:&apos;+timeTickArray[11]+&apos;},{\&quot;value\&quot;:&apos;+String.valueOf(randomValue.nextInt(90))+&apos;,\&quot;dataStatus\&quot;:0,\&quot;nodeStatus\&quot;:0,\&quot;timeStamp\&quot;:&apos;+timeTickArray[12]+&apos;},{\&quot;value\&quot;:&apos;+String.valueOf(randomValue.nextInt(90))+&apos;,\&quot;dataStatus\&quot;:0,\&quot;nodeStatus\&quot;:0,\&quot;timeStamp\&quot;:&apos;+timeTickArray[13]+&apos;},{\&quot;value\&quot;:&apos;+String.valueOf(randomValue.nextInt(90))+&apos;,\&quot;dataStatus\&quot;:0,\&quot;nodeStatus\&quot;:0,\&quot;timeStamp\&quot;:&apos;+timeTickArray[14]+&apos;},{\&quot;value\&quot;:&apos;+String.valueOf(randomValue.nextInt(90))+&apos;,\&quot;dataStatus\&quot;:0,\&quot;nodeStatus\&quot;:0,\&quot;timeStamp\&quot;:&apos;+timeTickArray[15]+&apos;},{\&quot;value\&quot;:&apos;+String.valueOf(randomValue.nextInt(90))+&apos;,\&quot;dataStatus\&quot;:0,\&quot;nodeStatus\&quot;:0,\&quot;timeStamp\&quot;:&apos;+timeTickArray[16]+&apos;},{\&quot;value\&quot;:&apos;+String.valueOf(randomValue.nextInt(90))+&apos;,\&quot;dataStatus\&quot;:0,\&quot;nodeStatus\&quot;:0,\&quot;timeStamp\&quot;:&apos;+timeTickArray[17]+&apos;},{\&quot;value\&quot;:&apos;+String.valueOf(randomValue.nextInt(90))+&apos;,\&quot;dataStatus\&quot;:0,\&quot;nodeStatus\&quot;:0,\&quot;timeStamp\&quot;:&apos;+timeTickArray[18]+&apos;},{\&quot;value\&quot;:&apos;+String.valueOf(randomValue.nextInt(90))+&apos;,\&quot;dataStatus\&quot;:0,\&quot;nodeStatus\&quot;:0,\&quot;timeStamp\&quot;:&apos;+timeTickArray[19]+&apos;},{\&quot;value\&quot;:&apos;+String.valueOf(randomValue.nextInt(90))+&apos;,\&quot;dataStatus\&quot;:0,\&quot;nodeStatus\&quot;:0,\&quot;timeStamp\&quot;:&apos;+timeTickArray[20]+&apos;},{\&quot;value\&quot;:&apos;+String.valueOf(randomValue.nextInt(90))+&apos;,\&quot;dataStatus\&quot;:0,\&quot;nodeStatus\&quot;:0,\&quot;timeStamp\&quot;:&apos;+timeTickArray[21]+&apos;},{\&quot;value\&quot;:&apos;+String.valueOf(randomValue.nextInt(90))+&apos;,\&quot;dataStatus\&quot;:0,\&quot;nodeStatus\&quot;:0,\&quot;timeStamp\&quot;:&apos;+timeTickArray[22]+&apos;},{\&quot;value\&quot;:&apos;+String.valueOf(randomValue.nextInt(90))+&apos;,\&quot;dataStatus\&quot;:0,\&quot;nodeStatus\&quot;:0,\&quot;timeStamp\&quot;:&apos;+timeTickArray[23]+&apos;},{\&quot;value\&quot;:&apos;+String.valueOf(randomValue.nextInt(90))+&apos;,\&quot;dataStatus\&quot;:0,\&quot;nodeStatus\&quot;:0,\&quot;timeStamp\&quot;:&apos;+timeTickArray[24]+&apos;},{\&quot;value\&quot;:&apos;+String.valueOf(randomValue.nextInt(90))+&apos;,\&quot;dataStatus\&quot;:0,\&quot;nodeStatus\&quot;:0,\&quot;timeStamp\&quot;:&apos;+timeTickArray[25]+&apos;},{\&quot;value\&quot;:&apos;+String.valueOf(randomValue.nextInt(90))+&apos;,\&quot;dataStatus\&quot;:0,\&quot;nodeStatus\&quot;:0,\&quot;timeStamp\&quot;:&apos;+timeTickArray[26]+&apos;},{\&quot;value\&quot;:&apos;+String.valueOf(randomValue.nextInt(90))+&apos;,\&quot;dataStatus\&quot;:0,\&quot;nodeStatus\&quot;:0,\&quot;timeStamp\&quot;:&apos;+timeTickArray[27]+&apos;},{\&quot;value\&quot;:&apos;+String.valueOf(randomValue.nextInt(90))+&apos;,\&quot;dataStatus\&quot;:0,\&quot;nodeStatus\&quot;:0,\&quot;timeStamp\&quot;:&apos;+timeTickArray[28]+&apos;},{\&quot;value\&quot;:&apos;+String.valueOf(randomValue.nextInt(90))+&apos;,\&quot;dataStatus\&quot;:0,\&quot;nodeStatus\&quot;:0,\&quot;timeStamp\&quot;:&apos;+timeTickArray[29]+&apos;}], &quot;sampleType&quot;: &quot;StaticDataSample&quot;},&apos;;

combSamplesStr = combSamplesStr+samplesSetStr;

}

strOnlineBody = reqParametersStr+combSamplesStr+closingBracketStr;

vars.put(&quot;Payload_SetPGOnlineTags&quot;, strOnlineBody);
</stringProp>
          <stringProp name="scriptLanguage">groovy</stringProp>
        </JSR223Sampler>
        <hashTree/>
        <HTTPSamplerProxy guiclass="HttpTestSampleGui" testclass="HTTPSamplerProxy" testname="Generate Token" enabled="true">
          <elementProp name="HTTPsampler.Arguments" elementType="Arguments" guiclass="HTTPArgumentsPanel" testclass="Arguments" testname="User Defined Variables" enabled="true">
            <collectionProp name="Arguments.arguments">
              <elementProp name="username" elementType="HTTPArgument">
                <boolProp name="HTTPArgument.always_encode">false</boolProp>
                <stringProp name="Argument.value">${username}</stringProp>
                <stringProp name="Argument.metadata">=</stringProp>
                <boolProp name="HTTPArgument.use_equals">true</boolProp>
                <stringProp name="Argument.name">username</stringProp>
              </elementProp>
              <elementProp name="password" elementType="HTTPArgument">
                <boolProp name="HTTPArgument.always_encode">false</boolProp>
                <stringProp name="Argument.value">${password}</stringProp>
                <stringProp name="Argument.metadata">=</stringProp>
                <boolProp name="HTTPArgument.use_equals">true</boolProp>
                <stringProp name="Argument.name">password</stringProp>
              </elementProp>
              <elementProp name="client_id" elementType="HTTPArgument">
                <boolProp name="HTTPArgument.always_encode">false</boolProp>
                <stringProp name="Argument.value">app-appshell</stringProp>
                <stringProp name="Argument.metadata">=</stringProp>
                <boolProp name="HTTPArgument.use_equals">true</boolProp>
                <stringProp name="Argument.name">client_id</stringProp>
              </elementProp>
              <elementProp name="grant_type" elementType="HTTPArgument">
                <boolProp name="HTTPArgument.always_encode">false</boolProp>
                <stringProp name="Argument.value">password</stringProp>
                <stringProp name="Argument.metadata">=</stringProp>
                <boolProp name="HTTPArgument.use_equals">true</boolProp>
                <stringProp name="Argument.name">grant_type</stringProp>
              </elementProp>
              <elementProp name="client_secret" elementType="HTTPArgument">
                <boolProp name="HTTPArgument.always_encode">false</boolProp>
                <stringProp name="Argument.value">${client_secret}</stringProp>
                <stringProp name="Argument.metadata">=</stringProp>
                <boolProp name="HTTPArgument.use_equals">true</boolProp>
                <stringProp name="Argument.name">client_secret</stringProp>
              </elementProp>
            </collectionProp>
          </elementProp>
          <stringProp name="HTTPSampler.domain">${TokenURL}</stringProp>
          <stringProp name="HTTPSampler.port"></stringProp>
          <stringProp name="HTTPSampler.protocol">HTTPS</stringProp>
          <stringProp name="HTTPSampler.contentEncoding"></stringProp>
          <stringProp name="HTTPSampler.path">auth/realms/${Tenant_Id}/protocol/openid-connect/token</stringProp>
          <stringProp name="HTTPSampler.method">POST</stringProp>
          <boolProp name="HTTPSampler.follow_redirects">true</boolProp>
          <boolProp name="HTTPSampler.auto_redirects">false</boolProp>
          <boolProp name="HTTPSampler.use_keepalive">true</boolProp>
          <boolProp name="HTTPSampler.DO_MULTIPART_POST">false</boolProp>
          <stringProp name="HTTPSampler.embedded_url_re"></stringProp>
          <stringProp name="HTTPSampler.connect_timeout"></stringProp>
          <stringProp name="HTTPSampler.response_timeout"></stringProp>
        </HTTPSamplerProxy>
        <hashTree>
          <JSONPostProcessor guiclass="JSONPostProcessorGui" testclass="JSONPostProcessor" testname="Fetch Token" enabled="true">
            <stringProp name="JSONPostProcessor.referenceNames">access_token</stringProp>
            <stringProp name="JSONPostProcessor.jsonPathExprs">$.access_token</stringProp>
            <stringProp name="JSONPostProcessor.match_numbers">1</stringProp>
          </JSONPostProcessor>
          <hashTree/>
        </hashTree>
        <HTTPSamplerProxy guiclass="HttpTestSampleGui" testclass="HTTPSamplerProxy" testname="PG Fetch Raw Data Request" enabled="true">
          <boolProp name="HTTPSampler.postBodyRaw">true</boolProp>
          <elementProp name="HTTPsampler.Arguments" elementType="Arguments">
            <collectionProp name="Arguments.arguments">
              <elementProp name="" elementType="HTTPArgument">
                <boolProp name="HTTPArgument.always_encode">false</boolProp>
                <stringProp name="Argument.value">${Payload_FetchPgRaw}</stringProp>
                <stringProp name="Argument.metadata">=</stringProp>
              </elementProp>
            </collectionProp>
          </elementProp>
          <stringProp name="HTTPSampler.domain">${AppURL}</stringProp>
          <stringProp name="HTTPSampler.port"></stringProp>
          <stringProp name="HTTPSampler.protocol">https</stringProp>
          <stringProp name="HTTPSampler.contentEncoding"></stringProp>
          <stringProp name="HTTPSampler.path">/timeseries/v1/query/data/raw</stringProp>
          <stringProp name="HTTPSampler.method">POST</stringProp>
          <boolProp name="HTTPSampler.follow_redirects">true</boolProp>
          <boolProp name="HTTPSampler.auto_redirects">false</boolProp>
          <boolProp name="HTTPSampler.use_keepalive">true</boolProp>
          <boolProp name="HTTPSampler.DO_MULTIPART_POST">false</boolProp>
          <stringProp name="HTTPSampler.embedded_url_re"></stringProp>
          <stringProp name="HTTPSampler.connect_timeout"></stringProp>
          <stringProp name="HTTPSampler.response_timeout"></stringProp>
        </HTTPSamplerProxy>
        <hashTree>
          <HeaderManager guiclass="HeaderPanel" testclass="HeaderManager" testname="HTTP Header Manager" enabled="true">
            <collectionProp name="HeaderManager.headers">
              <elementProp name="tenantID" elementType="Header">
                <stringProp name="Header.name">tenantID</stringProp>
                <stringProp name="Header.value">S1Enterprise</stringProp>
              </elementProp>
              <elementProp name="Authorization" elementType="Header">
                <stringProp name="Header.name">Authorization</stringProp>
                <stringProp name="Header.value">Bearer ${access_token}</stringProp>
              </elementProp>
              <elementProp name="Content-Type" elementType="Header">
                <stringProp name="Header.name">Content-Type</stringProp>
                <stringProp name="Header.value">application/json</stringProp>
              </elementProp>
            </collectionProp>
          </HeaderManager>
          <hashTree/>
          <ResponseAssertion guiclass="AssertionGui" testclass="ResponseAssertion" testname="Response Assertion" enabled="true">
            <collectionProp name="Asserion.test_strings">
              <stringProp name="49586">200</stringProp>
            </collectionProp>
            <stringProp name="Assertion.custom_message"></stringProp>
            <stringProp name="Assertion.test_field">Assertion.response_code</stringProp>
            <boolProp name="Assertion.assume_success">false</boolProp>
            <intProp name="Assertion.test_type">16</intProp>
          </ResponseAssertion>
          <hashTree/>
        </hashTree>
        <HTTPSamplerProxy guiclass="HttpTestSampleGui" testclass="HTTPSamplerProxy" testname="Pi Fetch Raw Data Request" enabled="true">
          <boolProp name="HTTPSampler.postBodyRaw">true</boolProp>
          <elementProp name="HTTPsampler.Arguments" elementType="Arguments">
            <collectionProp name="Arguments.arguments">
              <elementProp name="" elementType="HTTPArgument">
                <boolProp name="HTTPArgument.always_encode">false</boolProp>
                <stringProp name="Argument.value">${Payload_FetchPiRaw}</stringProp>
                <stringProp name="Argument.metadata">=</stringProp>
              </elementProp>
            </collectionProp>
          </elementProp>
          <stringProp name="HTTPSampler.domain">${AppURL}</stringProp>
          <stringProp name="HTTPSampler.port"></stringProp>
          <stringProp name="HTTPSampler.protocol">https</stringProp>
          <stringProp name="HTTPSampler.contentEncoding"></stringProp>
          <stringProp name="HTTPSampler.path">/timeseries/v1/query/data/raw</stringProp>
          <stringProp name="HTTPSampler.method">POST</stringProp>
          <boolProp name="HTTPSampler.follow_redirects">true</boolProp>
          <boolProp name="HTTPSampler.auto_redirects">false</boolProp>
          <boolProp name="HTTPSampler.use_keepalive">true</boolProp>
          <boolProp name="HTTPSampler.DO_MULTIPART_POST">false</boolProp>
          <stringProp name="HTTPSampler.embedded_url_re"></stringProp>
          <stringProp name="HTTPSampler.connect_timeout"></stringProp>
          <stringProp name="HTTPSampler.response_timeout"></stringProp>
        </HTTPSamplerProxy>
        <hashTree>
          <HeaderManager guiclass="HeaderPanel" testclass="HeaderManager" testname="HTTP Header Manager" enabled="true">
            <collectionProp name="HeaderManager.headers">
              <elementProp name="tenantID" elementType="Header">
                <stringProp name="Header.name">tenantID</stringProp>
                <stringProp name="Header.value">S1Enterprise</stringProp>
              </elementProp>
              <elementProp name="Authorization" elementType="Header">
                <stringProp name="Header.name">Authorization</stringProp>
                <stringProp name="Header.value">Bearer ${access_token}</stringProp>
              </elementProp>
              <elementProp name="Content-Type" elementType="Header">
                <stringProp name="Header.name">Content-Type</stringProp>
                <stringProp name="Header.value">application/json</stringProp>
              </elementProp>
            </collectionProp>
          </HeaderManager>
          <hashTree/>
          <ResponseAssertion guiclass="AssertionGui" testclass="ResponseAssertion" testname="Response Assertion" enabled="true">
            <collectionProp name="Asserion.test_strings">
              <stringProp name="49586">200</stringProp>
            </collectionProp>
            <stringProp name="Assertion.custom_message"></stringProp>
            <stringProp name="Assertion.test_field">Assertion.response_code</stringProp>
            <boolProp name="Assertion.assume_success">false</boolProp>
            <intProp name="Assertion.test_type">16</intProp>
          </ResponseAssertion>
          <hashTree/>
        </hashTree>
        <HTTPSamplerProxy guiclass="HttpTestSampleGui" testclass="HTTPSamplerProxy" testname="S1 Fetch Raw Data Request" enabled="true">
          <boolProp name="HTTPSampler.postBodyRaw">true</boolProp>
          <elementProp name="HTTPsampler.Arguments" elementType="Arguments">
            <collectionProp name="Arguments.arguments">
              <elementProp name="" elementType="HTTPArgument">
                <boolProp name="HTTPArgument.always_encode">false</boolProp>
                <stringProp name="Argument.value">${Payload_FetchS1Raw}</stringProp>
                <stringProp name="Argument.metadata">=</stringProp>
              </elementProp>
            </collectionProp>
          </elementProp>
          <stringProp name="HTTPSampler.domain">${AppURL}</stringProp>
          <stringProp name="HTTPSampler.port"></stringProp>
          <stringProp name="HTTPSampler.protocol">https</stringProp>
          <stringProp name="HTTPSampler.contentEncoding"></stringProp>
          <stringProp name="HTTPSampler.path">/timeseries/v1/query/data/raw</stringProp>
          <stringProp name="HTTPSampler.method">POST</stringProp>
          <boolProp name="HTTPSampler.follow_redirects">true</boolProp>
          <boolProp name="HTTPSampler.auto_redirects">false</boolProp>
          <boolProp name="HTTPSampler.use_keepalive">true</boolProp>
          <boolProp name="HTTPSampler.DO_MULTIPART_POST">false</boolProp>
          <stringProp name="HTTPSampler.embedded_url_re"></stringProp>
          <stringProp name="HTTPSampler.connect_timeout"></stringProp>
          <stringProp name="HTTPSampler.response_timeout"></stringProp>
        </HTTPSamplerProxy>
        <hashTree>
          <HeaderManager guiclass="HeaderPanel" testclass="HeaderManager" testname="HTTP Header Manager" enabled="true">
            <collectionProp name="HeaderManager.headers">
              <elementProp name="tenantID" elementType="Header">
                <stringProp name="Header.name">tenantID</stringProp>
                <stringProp name="Header.value">S1Enterprise</stringProp>
              </elementProp>
              <elementProp name="Authorization" elementType="Header">
                <stringProp name="Header.name">Authorization</stringProp>
                <stringProp name="Header.value">Bearer ${access_token}</stringProp>
              </elementProp>
              <elementProp name="Content-Type" elementType="Header">
                <stringProp name="Header.name">Content-Type</stringProp>
                <stringProp name="Header.value">application/json</stringProp>
              </elementProp>
            </collectionProp>
          </HeaderManager>
          <hashTree/>
          <ResponseAssertion guiclass="AssertionGui" testclass="ResponseAssertion" testname="Response Assertion" enabled="true">
            <collectionProp name="Asserion.test_strings">
              <stringProp name="49586">200</stringProp>
            </collectionProp>
            <stringProp name="Assertion.custom_message"></stringProp>
            <stringProp name="Assertion.test_field">Assertion.response_code</stringProp>
            <boolProp name="Assertion.assume_success">false</boolProp>
            <intProp name="Assertion.test_type">16</intProp>
          </ResponseAssertion>
          <hashTree/>
        </hashTree>
        <HTTPSamplerProxy guiclass="HttpTestSampleGui" testclass="HTTPSamplerProxy" testname="PG Fetch Summary Data Request" enabled="true">
          <boolProp name="HTTPSampler.postBodyRaw">true</boolProp>
          <elementProp name="HTTPsampler.Arguments" elementType="Arguments">
            <collectionProp name="Arguments.arguments">
              <elementProp name="" elementType="HTTPArgument">
                <boolProp name="HTTPArgument.always_encode">false</boolProp>
                <stringProp name="Argument.value">${Payload_FetchPgSummary}</stringProp>
                <stringProp name="Argument.metadata">=</stringProp>
              </elementProp>
            </collectionProp>
          </elementProp>
          <stringProp name="HTTPSampler.domain">${AppURL}</stringProp>
          <stringProp name="HTTPSampler.port"></stringProp>
          <stringProp name="HTTPSampler.protocol">https</stringProp>
          <stringProp name="HTTPSampler.contentEncoding"></stringProp>
          <stringProp name="HTTPSampler.path">/timeseries/v1/query/data/summary/static</stringProp>
          <stringProp name="HTTPSampler.method">POST</stringProp>
          <boolProp name="HTTPSampler.follow_redirects">true</boolProp>
          <boolProp name="HTTPSampler.auto_redirects">false</boolProp>
          <boolProp name="HTTPSampler.use_keepalive">true</boolProp>
          <boolProp name="HTTPSampler.DO_MULTIPART_POST">false</boolProp>
          <stringProp name="HTTPSampler.embedded_url_re"></stringProp>
          <stringProp name="HTTPSampler.connect_timeout"></stringProp>
          <stringProp name="HTTPSampler.response_timeout"></stringProp>
        </HTTPSamplerProxy>
        <hashTree>
          <HeaderManager guiclass="HeaderPanel" testclass="HeaderManager" testname="HTTP Header Manager" enabled="true">
            <collectionProp name="HeaderManager.headers">
              <elementProp name="tenantID" elementType="Header">
                <stringProp name="Header.name">tenantID</stringProp>
                <stringProp name="Header.value">S1Enterprise</stringProp>
              </elementProp>
              <elementProp name="Authorization" elementType="Header">
                <stringProp name="Header.name">Authorization</stringProp>
                <stringProp name="Header.value">Bearer ${access_token}</stringProp>
              </elementProp>
              <elementProp name="Content-Type" elementType="Header">
                <stringProp name="Header.name">Content-Type</stringProp>
                <stringProp name="Header.value">application/json</stringProp>
              </elementProp>
            </collectionProp>
          </HeaderManager>
          <hashTree/>
          <ResponseAssertion guiclass="AssertionGui" testclass="ResponseAssertion" testname="Response Assertion" enabled="true">
            <collectionProp name="Asserion.test_strings">
              <stringProp name="49586">200</stringProp>
            </collectionProp>
            <stringProp name="Assertion.custom_message"></stringProp>
            <stringProp name="Assertion.test_field">Assertion.response_code</stringProp>
            <boolProp name="Assertion.assume_success">false</boolProp>
            <intProp name="Assertion.test_type">16</intProp>
          </ResponseAssertion>
          <hashTree/>
        </hashTree>
        <HTTPSamplerProxy guiclass="HttpTestSampleGui" testclass="HTTPSamplerProxy" testname="Pi Fetch Summary Data Request" enabled="true">
          <boolProp name="HTTPSampler.postBodyRaw">true</boolProp>
          <elementProp name="HTTPsampler.Arguments" elementType="Arguments">
            <collectionProp name="Arguments.arguments">
              <elementProp name="" elementType="HTTPArgument">
                <boolProp name="HTTPArgument.always_encode">false</boolProp>
                <stringProp name="Argument.value">${Payload_FetchPiSummary}</stringProp>
                <stringProp name="Argument.metadata">=</stringProp>
              </elementProp>
            </collectionProp>
          </elementProp>
          <stringProp name="HTTPSampler.domain">${AppURL}</stringProp>
          <stringProp name="HTTPSampler.port"></stringProp>
          <stringProp name="HTTPSampler.protocol">https</stringProp>
          <stringProp name="HTTPSampler.contentEncoding"></stringProp>
          <stringProp name="HTTPSampler.path">/timeseries/v1/query/data/summary/static</stringProp>
          <stringProp name="HTTPSampler.method">POST</stringProp>
          <boolProp name="HTTPSampler.follow_redirects">true</boolProp>
          <boolProp name="HTTPSampler.auto_redirects">false</boolProp>
          <boolProp name="HTTPSampler.use_keepalive">true</boolProp>
          <boolProp name="HTTPSampler.DO_MULTIPART_POST">false</boolProp>
          <stringProp name="HTTPSampler.embedded_url_re"></stringProp>
          <stringProp name="HTTPSampler.connect_timeout"></stringProp>
          <stringProp name="HTTPSampler.response_timeout"></stringProp>
        </HTTPSamplerProxy>
        <hashTree>
          <HeaderManager guiclass="HeaderPanel" testclass="HeaderManager" testname="HTTP Header Manager" enabled="true">
            <collectionProp name="HeaderManager.headers">
              <elementProp name="tenantID" elementType="Header">
                <stringProp name="Header.name">tenantID</stringProp>
                <stringProp name="Header.value">S1Enterprise</stringProp>
              </elementProp>
              <elementProp name="Authorization" elementType="Header">
                <stringProp name="Header.name">Authorization</stringProp>
                <stringProp name="Header.value">Bearer ${access_token}</stringProp>
              </elementProp>
              <elementProp name="Content-Type" elementType="Header">
                <stringProp name="Header.name">Content-Type</stringProp>
                <stringProp name="Header.value">application/json</stringProp>
              </elementProp>
            </collectionProp>
          </HeaderManager>
          <hashTree/>
          <ResponseAssertion guiclass="AssertionGui" testclass="ResponseAssertion" testname="Response Assertion" enabled="true">
            <collectionProp name="Asserion.test_strings">
              <stringProp name="49586">200</stringProp>
            </collectionProp>
            <stringProp name="Assertion.custom_message"></stringProp>
            <stringProp name="Assertion.test_field">Assertion.response_code</stringProp>
            <boolProp name="Assertion.assume_success">false</boolProp>
            <intProp name="Assertion.test_type">16</intProp>
          </ResponseAssertion>
          <hashTree/>
        </hashTree>
        <HTTPSamplerProxy guiclass="HttpTestSampleGui" testclass="HTTPSamplerProxy" testname="S1 Fetch Summary Data Request" enabled="true">
          <boolProp name="HTTPSampler.postBodyRaw">true</boolProp>
          <elementProp name="HTTPsampler.Arguments" elementType="Arguments">
            <collectionProp name="Arguments.arguments">
              <elementProp name="" elementType="HTTPArgument">
                <boolProp name="HTTPArgument.always_encode">false</boolProp>
                <stringProp name="Argument.value">${Payload_FetchS1Summary}</stringProp>
                <stringProp name="Argument.metadata">=</stringProp>
              </elementProp>
            </collectionProp>
          </elementProp>
          <stringProp name="HTTPSampler.domain">${AppURL}</stringProp>
          <stringProp name="HTTPSampler.port"></stringProp>
          <stringProp name="HTTPSampler.protocol">https</stringProp>
          <stringProp name="HTTPSampler.contentEncoding"></stringProp>
          <stringProp name="HTTPSampler.path">/timeseries/v1/query/data/summary/static</stringProp>
          <stringProp name="HTTPSampler.method">POST</stringProp>
          <boolProp name="HTTPSampler.follow_redirects">true</boolProp>
          <boolProp name="HTTPSampler.auto_redirects">false</boolProp>
          <boolProp name="HTTPSampler.use_keepalive">true</boolProp>
          <boolProp name="HTTPSampler.DO_MULTIPART_POST">false</boolProp>
          <stringProp name="HTTPSampler.embedded_url_re"></stringProp>
          <stringProp name="HTTPSampler.connect_timeout"></stringProp>
          <stringProp name="HTTPSampler.response_timeout"></stringProp>
        </HTTPSamplerProxy>
        <hashTree>
          <HeaderManager guiclass="HeaderPanel" testclass="HeaderManager" testname="HTTP Header Manager" enabled="true">
            <collectionProp name="HeaderManager.headers">
              <elementProp name="tenantID" elementType="Header">
                <stringProp name="Header.name">tenantID</stringProp>
                <stringProp name="Header.value">S1Enterprise</stringProp>
              </elementProp>
              <elementProp name="Authorization" elementType="Header">
                <stringProp name="Header.name">Authorization</stringProp>
                <stringProp name="Header.value">Bearer ${access_token}</stringProp>
              </elementProp>
              <elementProp name="Content-Type" elementType="Header">
                <stringProp name="Header.name">Content-Type</stringProp>
                <stringProp name="Header.value">application/json</stringProp>
              </elementProp>
            </collectionProp>
          </HeaderManager>
          <hashTree/>
          <ResponseAssertion guiclass="AssertionGui" testclass="ResponseAssertion" testname="Response Assertion" enabled="true">
            <collectionProp name="Asserion.test_strings">
              <stringProp name="49586">200</stringProp>
            </collectionProp>
            <stringProp name="Assertion.custom_message"></stringProp>
            <stringProp name="Assertion.test_field">Assertion.response_code</stringProp>
            <boolProp name="Assertion.assume_success">false</boolProp>
            <intProp name="Assertion.test_type">16</intProp>
          </ResponseAssertion>
          <hashTree/>
        </hashTree>
        <HTTPSamplerProxy guiclass="HttpTestSampleGui" testclass="HTTPSamplerProxy" testname="Set Offline PG Tags Data Request" enabled="true">
          <boolProp name="HTTPSampler.postBodyRaw">true</boolProp>
          <elementProp name="HTTPsampler.Arguments" elementType="Arguments">
            <collectionProp name="Arguments.arguments">
              <elementProp name="" elementType="HTTPArgument">
                <boolProp name="HTTPArgument.always_encode">false</boolProp>
                <stringProp name="Argument.value">${Payload_SetPGOfflineTags}</stringProp>
                <stringProp name="Argument.metadata">=</stringProp>
              </elementProp>
            </collectionProp>
          </elementProp>
          <stringProp name="HTTPSampler.domain">${AppURL}</stringProp>
          <stringProp name="HTTPSampler.port"></stringProp>
          <stringProp name="HTTPSampler.protocol">https</stringProp>
          <stringProp name="HTTPSampler.contentEncoding"></stringProp>
          <stringProp name="HTTPSampler.path">/timeseries/v1/data/static</stringProp>
          <stringProp name="HTTPSampler.method">POST</stringProp>
          <boolProp name="HTTPSampler.follow_redirects">true</boolProp>
          <boolProp name="HTTPSampler.auto_redirects">false</boolProp>
          <boolProp name="HTTPSampler.use_keepalive">true</boolProp>
          <boolProp name="HTTPSampler.DO_MULTIPART_POST">false</boolProp>
          <stringProp name="HTTPSampler.embedded_url_re"></stringProp>
          <stringProp name="HTTPSampler.connect_timeout"></stringProp>
          <stringProp name="HTTPSampler.response_timeout"></stringProp>
        </HTTPSamplerProxy>
        <hashTree>
          <HeaderManager guiclass="HeaderPanel" testclass="HeaderManager" testname="HTTP Header Manager" enabled="true">
            <collectionProp name="HeaderManager.headers">
              <elementProp name="" elementType="Header">
                <stringProp name="Header.name">tenantID</stringProp>
                <stringProp name="Header.value">${tenant}</stringProp>
              </elementProp>
              <elementProp name="" elementType="Header">
                <stringProp name="Header.name">Content-Type</stringProp>
                <stringProp name="Header.value">application/json</stringProp>
              </elementProp>
              <elementProp name="Authorization" elementType="Header">
                <stringProp name="Header.name">Authorization</stringProp>
                <stringProp name="Header.value">Bearer ${access_token}</stringProp>
              </elementProp>
            </collectionProp>
          </HeaderManager>
          <hashTree/>
          <ResponseAssertion guiclass="AssertionGui" testclass="ResponseAssertion" testname="Response Assertion" enabled="true">
            <collectionProp name="Asserion.test_strings">
              <stringProp name="49586">200</stringProp>
            </collectionProp>
            <stringProp name="Assertion.custom_message"></stringProp>
            <stringProp name="Assertion.test_field">Assertion.response_code</stringProp>
            <boolProp name="Assertion.assume_success">false</boolProp>
            <intProp name="Assertion.test_type">16</intProp>
          </ResponseAssertion>
          <hashTree/>
        </hashTree>
        <HTTPSamplerProxy guiclass="HttpTestSampleGui" testclass="HTTPSamplerProxy" testname="Set Online PG Tags Data Request" enabled="true">
          <boolProp name="HTTPSampler.postBodyRaw">true</boolProp>
          <elementProp name="HTTPsampler.Arguments" elementType="Arguments">
            <collectionProp name="Arguments.arguments">
              <elementProp name="" elementType="HTTPArgument">
                <boolProp name="HTTPArgument.always_encode">false</boolProp>
                <stringProp name="Argument.value">${Payload_SetPGOnlineTags}</stringProp>
                <stringProp name="Argument.metadata">=</stringProp>
              </elementProp>
            </collectionProp>
          </elementProp>
          <stringProp name="HTTPSampler.domain">${AppURL}</stringProp>
          <stringProp name="HTTPSampler.port"></stringProp>
          <stringProp name="HTTPSampler.protocol">https</stringProp>
          <stringProp name="HTTPSampler.contentEncoding"></stringProp>
          <stringProp name="HTTPSampler.path">/timeseries/v1/data/static</stringProp>
          <stringProp name="HTTPSampler.method">POST</stringProp>
          <boolProp name="HTTPSampler.follow_redirects">true</boolProp>
          <boolProp name="HTTPSampler.auto_redirects">false</boolProp>
          <boolProp name="HTTPSampler.use_keepalive">true</boolProp>
          <boolProp name="HTTPSampler.DO_MULTIPART_POST">false</boolProp>
          <stringProp name="HTTPSampler.embedded_url_re"></stringProp>
          <stringProp name="HTTPSampler.connect_timeout"></stringProp>
          <stringProp name="HTTPSampler.response_timeout"></stringProp>
        </HTTPSamplerProxy>
        <hashTree>
          <HeaderManager guiclass="HeaderPanel" testclass="HeaderManager" testname="HTTP Header Manager" enabled="true">
            <collectionProp name="HeaderManager.headers">
              <elementProp name="" elementType="Header">
                <stringProp name="Header.name">tenantID</stringProp>
                <stringProp name="Header.value">${tenant}</stringProp>
              </elementProp>
              <elementProp name="" elementType="Header">
                <stringProp name="Header.name">Content-Type</stringProp>
                <stringProp name="Header.value">application/json</stringProp>
              </elementProp>
              <elementProp name="Authorization" elementType="Header">
                <stringProp name="Header.name">Authorization</stringProp>
                <stringProp name="Header.value">Bearer ${access_token}</stringProp>
              </elementProp>
            </collectionProp>
          </HeaderManager>
          <hashTree/>
          <ResponseAssertion guiclass="AssertionGui" testclass="ResponseAssertion" testname="Response Assertion" enabled="true">
            <collectionProp name="Asserion.test_strings">
              <stringProp name="49586">200</stringProp>
            </collectionProp>
            <stringProp name="Assertion.custom_message"></stringProp>
            <stringProp name="Assertion.test_field">Assertion.response_code</stringProp>
            <boolProp name="Assertion.assume_success">false</boolProp>
            <intProp name="Assertion.test_type">16</intProp>
          </ResponseAssertion>
          <hashTree/>
        </hashTree>
        <JSR223Sampler guiclass="TestBeanGUI" testclass="JSR223Sampler" testname="Fetch Raw Api Body" enabled="false">
          <stringProp name="cacheKey">true</stringProp>
          <stringProp name="filename"></stringProp>
          <stringProp name="parameters"></stringProp>
          <stringProp name="script">import groovy.json.*

String groupIdStr = &quot;&quot;;

if(&quot;S1&quot;){groupIdStr = &quot;&quot;;} 
else if(&quot;PI&quot;){groupIdStr = &quot;&quot;;}
else if(&quot;PG&quot;){groupIdStr = &quot;&quot;;}


String str1 = &quot;{&quot;;
String str2 = groupIdStr;
String str3 = &quot;\&quot;tagIds\&quot;:&quot;;
String str4 = String.valueOf(quotesTagsForReq);
String timestampStr = vars.get(&quot;timestampString&quot;);
String str8 = &quot;,\&quot;TriggerType\&quot;: \&quot;Trend\&quot;,\&quot;maxNumberOfSamplesPerTag\&quot;: 2,\&quot;requestedStatusBits\&quot;: 0,\&quot;associatedTagIds\&quot;: {}&quot;;
String str9 = &quot;}&quot;;

String fetchRawCallBody = str1+str2+str3+str4+str5+str6+str7+str8+str9;
log.info(String.valueOf(fetchRawCallBody));

vars.put(&quot;Payload_FetchRaw&quot;, fetchRawCallBody);


</stringProp>
          <stringProp name="scriptLanguage">groovy</stringProp>
        </JSR223Sampler>
        <hashTree/>
        <JSR223Sampler guiclass="TestBeanGUI" testclass="JSR223Sampler" testname="Fetch Summary Api Body" enabled="false">
          <stringProp name="cacheKey">true</stringProp>
          <stringProp name="filename"></stringProp>
          <stringProp name="parameters"></stringProp>
          <stringProp name="script">import groovy.json.*

String groupIdStr = &quot;&quot;;

// Will need to add one line to read group id, can get it through a row in csv. Or maybe, we can add a separate cell for s1,pi,pg

if(&quot;S1&quot;){groupIdStr = &quot;&quot;;} 
else if(&quot;PI&quot;){groupIdStr = &quot;&quot;;}
else if(&quot;PG&quot;){groupIdStr = &quot;&quot;;}

String str1 = &quot;{&quot;;
String str2 = groupIdStr;
String str3 = &quot;\&quot;tagIds\&quot;:&quot;;
String str4 = String.valueOf(quotesTagsForReq);
String str5 = &quot;,\&quot;startTimes\&quot;:&quot;;
String str6 = String.valueOf(vars.get(&quot;&quot;));
String str7 = &quot;,\&quot;endTime\&quot;:&quot;+String.valueOf(vars.get(&quot;&quot;));
String str8 = &quot;,\&quot;summaryTypes\&quot;:[\&quot;MinValue\&quot;,\&quot;MaxValue\&quot;],\&quot;triggerTypeProportions\&quot;:{\&quot;Trend\&quot;:\&quot;60\&quot;,\&quot;Alarm\&quot;:\&quot;30\&quot;,\&quot;Transient\&quot;:\&quot;10\&quot;},\&quot;maxNumberOfSamplesPerTag\&quot;: 30,\&quot;requestedStatusBits\&quot;:0,\&quot;associatedTagIds\&quot;:{}&quot;;
String str9 = &quot;}&quot;;



String fetchSummaryCallBody = str1+str2+str3+str4+str5+str6+str7+str8+str9;
log.info(String.valueOf(fetchSummaryCallBody));

vars.put(&quot;Payload_FetchSummary&quot;, fetchSummaryCallBody);


</stringProp>
          <stringProp name="scriptLanguage">groovy</stringProp>
        </JSR223Sampler>
        <hashTree/>
        <HTTPSamplerProxy guiclass="HttpTestSampleGui" testclass="HTTPSamplerProxy" testname="SetOnlineData" enabled="false">
          <boolProp name="HTTPSampler.postBodyRaw">true</boolProp>
          <elementProp name="HTTPsampler.Arguments" elementType="Arguments">
            <collectionProp name="Arguments.arguments">
              <elementProp name="" elementType="HTTPArgument">
                <boolProp name="HTTPArgument.always_encode">false</boolProp>
                <stringProp name="Argument.value">${Payload}</stringProp>
                <stringProp name="Argument.metadata">=</stringProp>
              </elementProp>
            </collectionProp>
          </elementProp>
          <stringProp name="HTTPSampler.domain">${AppURL}</stringProp>
          <stringProp name="HTTPSampler.port"></stringProp>
          <stringProp name="HTTPSampler.protocol">https</stringProp>
          <stringProp name="HTTPSampler.contentEncoding"></stringProp>
          <stringProp name="HTTPSampler.path">/timeseries/v1/data/static</stringProp>
          <stringProp name="HTTPSampler.method">POST</stringProp>
          <boolProp name="HTTPSampler.follow_redirects">true</boolProp>
          <boolProp name="HTTPSampler.auto_redirects">false</boolProp>
          <boolProp name="HTTPSampler.use_keepalive">true</boolProp>
          <boolProp name="HTTPSampler.DO_MULTIPART_POST">false</boolProp>
          <stringProp name="HTTPSampler.embedded_url_re"></stringProp>
          <stringProp name="HTTPSampler.connect_timeout"></stringProp>
          <stringProp name="HTTPSampler.response_timeout"></stringProp>
        </HTTPSamplerProxy>
        <hashTree>
          <JSR223PreProcessor guiclass="TestBeanGUI" testclass="JSR223PreProcessor" testname="Payload Generator" enabled="true">
            <stringProp name="scriptLanguage">groovy</stringProp>
            <stringProp name="parameters"></stringProp>
            <stringProp name="filename"></stringProp>
            <stringProp name="cacheKey">false</stringProp>
            <stringProp name="script">import groovy.json.*

import java.util.GregorianCalendar;
import java.util.Calendar;
import java.util.Date;

import java.util.Random;



// THREAD 1 KA GROUP NUM not getting created last one is getting created twice[need to check ki once all threads are in, repeat nahi ho rha hai
// group id AS IT MAY CAUSE ISSUE OF LOCKING.

log.info(&quot;*****THREAD NUM USING CTX******&quot;);
log.info(&quot;num of threads----&gt;&quot;+ctx.getThreadGroup().getNumberOfThreads());
log.info(&quot;*****ZZZZZZZZZZZZ THREAD NUM USING CTX******&quot;);

//log.info(&quot;*****SET SET SET SET ******&quot;);
//log.info(&quot;thread(${__threadNum})&quot;)
//log.info(&quot;*****I I I i i i ******&quot;);
//
//String strThrNum = &quot;&quot;;
//strThrNum=&quot;thread(${__threadNum})&quot;;
//   String thrNumberOnly= strThrNum.replaceAll(&quot;[^0-9]&quot;, &quot;&quot;);
////   log.info(&quot;-----strThrNum:--------------&quot;);
////   log.info(strThrNum);
//    log.info(&quot;-------thrNumberOnly:------------&quot;);
//   log.info(thrNumberOnly);
//    log.info(&quot;-------------------&quot;);

//    log.info(&quot;SET DATA Iteration value: &quot;+String.valueOf(vars.getIteration()));
////def long curIterMod = 0;
//String curIter = String.valueOf(vars.getIteration());
//log.info(&quot;cur iter variable&quot;);
//log.info(curIter);
//log.info(&quot;cur iter variable&quot;);
//log.info(&quot;MODULO cur iter variable&quot;);
//String curIterMod = String.valueOf(vars.getIteration()%50); 

//log.info(&quot;*****SET SET SET SET ******&quot;);
//log.info(&quot;thread(${__threadNum})&quot;)
//log.info(&quot;*****I I I i i i ******&quot;);
//
//String strThrNum = &quot;&quot;;
//strThrNum=&quot;thread(${__threadNum})&quot;;
//   String thrNumberOnly= strThrNum.replaceAll(&quot;[^0-9]&quot;, &quot;&quot;);
////   log.info(&quot;-----strThrNum:--------------&quot;);
////   log.info(strThrNum);
//    log.info(&quot;-------thrNumberOnly:------------&quot;);
//   log.info(thrNumberOnly);
//    log.info(&quot;-------------------&quot;);
//
////  Integer curGroupNum = 0;
////  curGroupNum = Integer.valueOf(thrNumberOnly);
////log.info(&quot;-----------curGroupNum--------&quot;);
////   log.info(String.valueOf(curGroupNum));
////   log.info(&quot;-----------curGroupNum--------&quot;);
//    
//
//log.info(&quot;SET DATA Iteration value: &quot;+String.valueOf(vars.getIteration()));
////def long curIterMod = 0;
//String curIter = String.valueOf(vars.getIteration());
//log.info(&quot;cur iter variable&quot;);
//log.info(curIter);
//log.info(&quot;cur iter variable&quot;);
//log.info(&quot;MODULO cur iter variable&quot;);
//String curIterMod = String.valueOf(vars.getIteration()%50); 
//
//if(curIterMod==&apos;0&apos;){
//	curIterMod=&apos;50&apos;;
//}
//
////found the sneaky little bug :) placed the beliw line appropriately now:
//Integer curIterModInt = Integer.valueOf(curIterMod);
//
//log.info(&quot;cur MODULO iter variable: &quot;+curIterMod);
//
//// Integer curGroupNum = 0;
////      Integer threadNumInt = 0;
// Integer threadNumInt = Integer.valueOf(thrNumberOnly);
//  if(threadNumInt==1){
//  	Integer tempCurGroupNum=(2*curIterModInt)-1; vars.put(&quot;CUR_GROUP_NUM_VAR&quot;,String.valueOf(tempCurGroupNum));
//  	}
//  else if(threadNumInt==2){
//  	Integer tempCurGroupNum=(2*curIterModInt); vars.put(&quot;CUR_GROUP_NUM_VAR&quot;,String.valueOf(tempCurGroupNum));
//  	}
//
//Integer curGroupNum = Integer.valueOf(vars.get(&quot;CUR_GROUP_NUM_VAR&quot;));
//
//log.info(&quot;-----------curGroupNum--------&quot;);
//   log.info(String.valueOf(curGroupNum));
//   log.info(&quot;-----------curGroupNum--------&quot;);
//
//   log.info(&quot;-----------if thr1, (2*curIterMod1)-1 ====&quot;);
//   log.info(String.valueOf(curGroupNum));
//   log.info(&quot;-----------if thr1, (2*curIterMod1)-1  =====&quot;);
//
//   log.info(&quot;-----------if thr2, (2*curIterMod1) =====&quot;);
//   log.info(String.valueOf(curGroupNum));
//   log.info(&quot;-----------if thr2, (2*curIterMod1) ====&quot;);
//
//   String curGroupStr = String.valueOf(curGroupNum);
//
////log.info(vars.get(&quot;loopCount&quot;));
////vars.put(&quot;loopC
////log.info(vars.get(&quot;loopCount&quot;));
////log.info(String.valueOf(vars.getIteration()));
////log.info(String.valueOf(${__P(group1.threads)}));
////log.info(&quot;iteration value&quot;);
//
////log.info(&quot;2 START TIME:2 -----------&quot;);
////log.info(vars.get(&quot;currentStartTime&quot;));
////
////log.info(&quot;2 END TIME:---2 --------&quot;);
////log.info(vars.get(&quot;currentEndTime&quot;));
////
////
////log.info(&quot;2 START TIME: MILLIS-----2------&quot;);
////log.info(vars.get(&quot;curStartTimeMillis&quot;));
////
////log.info(&quot;2 END TIME: MILLIS----2-------&quot;);
////log.info(vars.get(&quot;curEndTimeMillis&quot;));
//
////log.info(&quot;3 START TIME:CAL DATE----3-------&quot;);
//
//// NEED TO CONVERT IT TO BIGINTEGER:
//
//
//BigInteger timeStamp = 0;
//Long startTimeStamp = 0;
//Long endTimeStamp = 0;
////BigInteger curStartTimeMillisLocVar = 0;
//Long curStartTimeMillisLocVar = 0;
//
//Long CUR_SET_StartTimeMillisLocVar = 0;
//Long CUR_SET_EndTimeMillisLocVar = 0;
//
//Long thread1StartTimeMillisLocVar = 0;
//Long thread2StartTimeMillisLocVar = 0;
//
//BigInteger curEndTimeMillisLocVar = 0;
//BigInteger tempStartTimeMillisLocVar = 0;
////BigInteger incTicks = 600000000;
//
//BigInteger[] timeTickArray = new BigInteger[30];
//
////////////-------------
//
//
//Calendar c = Calendar.getInstance();
//Calendar temp_c = Calendar.getInstance();
//
//Calendar CUR_SET_c = Calendar.getInstance();
//
//CUR_SET_c.setTimeInMillis(c.getTimeInMillis()); 
//CUR_SET_c.add(Calendar.MINUTE, -11);
////CUR_SET_c.add(Calendar.MONTH, 1);
//
//
//thread1StartTimeMillisLocVar=CUR_SET_c.getTimeInMillis();
//log.info(&quot;IN THREAD 1: CHECK MILLIS AND COMPARE WITH 2:&quot;);
//log.info(String.valueOf(thread1StartTimeMillisLocVar)); 
////vars will not help much as its not true global.
//vars.put(&quot;thread1StartTimeMillis&quot;,String.valueOf(thread1StartTimeMillisLocVar)); 
////props will only help as its true global.
////props.put(&quot;propthread1StartTimeMillis&quot;,String.valueOf(thread1StartTimeMillisLocVar));
//
//
////vars.put(&quot;curStartTimeMillis&quot;,String.valueOf(thread1StartTimeMillisLocVar)); 
//
//
/////////
//
//CUR_SET_StartTimeMillisLocVar=CUR_SET_c.getTimeInMillis();
//
//TimeZone tz1 = CUR_SET_c.getTimeZone();
//int offsetFromUTC1 = tz1.getOffset(CUR_SET_StartTimeMillisLocVar);
//log.debug(&quot;offset is &quot; + offsetFromUTC1);
//
//CUR_SET_c.add(Calendar.MILLISECOND, offsetFromUTC1);
//
//log.debug(&quot;Created GMT cal with date [&quot; + CUR_SET_c.getTime() + &quot;]&quot;);
//
////vars.put(&quot;CUR_SET_START_TIME_MILLIS&quot;,String.valueOf(CUR_SET_StartTimeMillisLocVar)); 
////vars.put(&quot;curStartTimeMillis&quot;,String.valueOf(CUR_SET_StartTimeMillisLocVar));
////
////startTimeStamp = (CUR_SET_c.getTimeInMillis() * 10000) + 621355968000000000 - 26586006500000;
//// 621355968000000000
//startTimeStamp = (CUR_SET_c.getTimeInMillis() * 10000) + 621355968000000000;
////or
////startTimeStamp = (CUR_SET_StartTimeMillisLocVar * 10000) + 621355968000000000 - 26586006500000;
////vars.put(&quot;curStartTimeMillis&quot;,String.valueOf(CUR_SET_StartTimeMillisLocVar));
////vars.put(&quot;currentStartTime&quot;,String.valueOf(startTimeStamp));
////vars.put(&quot;CUR_SET_END_TIME&quot;,);
//
////endtimestamp
//CUR_SET_c.add(Calendar.MINUTE, 10);
//// 621355968000000000
////endTimeStamp = (CUR_SET_c.getTimeInMillis() * 10000) + 621355968000000000 - 26586006500000;
//endTimeStamp = (CUR_SET_c.getTimeInMillis() * 10000) + 621355968000000000;
////vars.put(&quot;currentEndTime&quot;,String.valueOf(endTimeStamp));
//CUR_SET_EndTimeMillisLocVar = CUR_SET_c.getTimeInMillis();
////
////vars.put(&quot;curStartTimeMillis&quot;,String.valueOf(CUR_SET_StartTimeMillisLocVar));
//vars.put(&quot;curEndTimeMillis&quot;,String.valueOf(CUR_SET_EndTimeMillisLocVar));
////
//vars.put(&quot;currentStartTime&quot;, String.valueOf(startTimeStamp));
//vars.put(&quot;currentEndTime&quot;, String.valueOf(endTimeStamp));
//
//log.info(&quot;CURRENT START TIME MILLIS USER VARIABLE VALUE:&quot;);
//log.info(String.valueOf(vars.get(&quot;curStartTimeMillis&quot;)));
//
//log.info(&quot;CURRENT END TIME MILLIS USER VARIABLE VALUE:&quot;);
//log.info(String.valueOf(vars.get(&quot;curEndTimeMillis&quot;)));
//
//CUR_SET_c.setTimeInMillis(c.getTimeInMillis()); 
//
//CUR_SET_c.add(Calendar.MINUTE, -11);
//CUR_SET_c.add(Calendar.MONTH, 1);
//
////CUR_SET_c.add(Calendar.DATE, 1);
//
////CUR_SET_c.add(Calendar.MILLISECOND, 2000);
//CUR_SET_c.add(Calendar.SECOND,-6);
//
//
//
////
//
//thread2StartTimeMillisLocVar=CUR_SET_c.getTimeInMillis();
//log.info(&quot;IN THREAD 2: CHECK MILLIS AND COMPARE WITH 1:&quot;);
//log.info(String.valueOf(thread2StartTimeMillisLocVar)); 
//vars.put(&quot;thread2StartTimeMillis&quot;,String.valueOf(thread2StartTimeMillisLocVar)); 
//
//
/////////
//
//CUR_SET_StartTimeMillisLocVar=CUR_SET_c.getTimeInMillis();
//
//TimeZone tz2 = CUR_SET_c.getTimeZone();
//int offsetFromUTC2 = tz2.getOffset(CUR_SET_StartTimeMillisLocVar);
//log.debug(&quot;offset is &quot; + offsetFromUTC2);
//
//CUR_SET_c.add(Calendar.MILLISECOND, offsetFromUTC2);
//CUR_SET_c.add(Calendar.MILLISECOND, -10);
//log.debug(&quot;Created GMT cal with date [&quot; + CUR_SET_c.getTime() + &quot;]&quot;);
//vars.put(&quot;CUR_SET_START_TIME_MILLIS&quot;,String.valueOf(CUR_SET_StartTimeMillisLocVar)); 
//vars.put(&quot;curStartTimeMillis&quot;,String.valueOf(CUR_SET_StartTimeMillisLocVar));
////
////startTimeStamp = (CUR_SET_c.getTimeInMillis() * 10000) + 621355968000000000 - 26586006500000;
//startTimeStamp = (CUR_SET_c.getTimeInMillis() * 10000) + 621355968000000000;
//
////or
////startTimeStamp = (CUR_SET_StartTimeMillisLocVar * 10000) + 621355968000000000 - 26586006500000;
//vars.put(&quot;curStartTimeMillis&quot;,String.valueOf(CUR_SET_StartTimeMillisLocVar));
//
////endtimestamp
//CUR_SET_c.add(Calendar.MINUTE, 10);
////endTimeStamp = (CUR_SET_c.getTimeInMillis() * 10000) + 621355968000000000 - 26586006500000;
//endTimeStamp = (CUR_SET_c.getTimeInMillis() * 10000) + 621355968000000000;
//CUR_SET_EndTimeMillisLocVar = CUR_SET_c.getTimeInMillis();
////
////vars.put(&quot;curStartTimeMillis&quot;,String.valueOf(CUR_SET_StartTimeMillisLocVar));
//vars.put(&quot;curEndTimeMillis&quot;,String.valueOf(CUR_SET_EndTimeMillisLocVar));
////
//vars.put(&quot;currentStartTime&quot;, String.valueOf(startTimeStamp));
//vars.put(&quot;currentEndTime&quot;, String.valueOf(endTimeStamp));
//
//log.info(&quot;CURRENT START TIME MILLIS USER VARIABLE VALUE:&quot;);
//log.info(String.valueOf(vars.get(&quot;curStartTimeMillis&quot;)));
//
//log.info(&quot;CURRENT END TIME MILLIS USER VARIABLE VALUE:&quot;);
//log.info(String.valueOf(vars.get(&quot;curEndTimeMillis&quot;)));
//
//
//
//
////////////////------------
//
//
//Long curStartTimeMS = Long.valueOf(vars.get(&quot;curStartTimeMillis&quot;));
////log.info(String.valueOf(curTimeMS));
//
////log.info(&quot;3 START TIME:CAL DATE----3-------&quot;);
//Long curEndTimeMS = Long.valueOf(vars.get(&quot;curEndTimeMillis&quot;));
////log.info(String.valueOf(endTimeMS));

Calendar setCal = Calendar.getInstance();

setCal.add(Calendar.MINUTE, -11);

//setCal.setTimeInMillis(curStartTimeMS);
//log.info(String.valueOf(setCal.getTime()));


//
//Calendar setCal2 = Calendar.getInstance();
//setCal2.setTimeInMillis(curEndTimeMS);
////log.info(String.valueOf(setCal2.getTime()));




//String groupName = ctx.getThreadGroup().getName();
// BigInteger threadNumber = ctx.getThreadGroup().getThreadNum();
//BigInteger threadName = ctx.getThreadGroup().getThreadName();
//log.info(groupName);
//log.info(String.valueOf(threadNumber));

// WORKS: log.info(&quot;thread(${__threadNum})&quot;)
//log.info(&quot;thread(${__threadNum})&quot;)


//BigInteger timeStamp = 0;
//BigInteger startTimeStamp = 0;
//BigInteger incTicks = 600000000;

//Calendar c = Calendar.getInstance();


// USE VARIABLES FOR CONCURRENT USERS IN CODE KEEP IT AS A VARIABLE AND KEEP INCREASING IT BY 100 EVERY 1 SECOND OR SOMETHING LIKE THAT
// use ultimate thread group bzm thats it

//c.set(2021,01,01)
//c.set(2022,11,02);
//
//c.set(Calendar.HOUR, 00);
//
//c.set(Calendar.MINUTE, 00);
//
//c.set(Calendar.SECOND, 00);
//log.info(String.valueOf(c));
//log.info(&quot;00000000000&quot;);


// 26586006500000
// 621355968010000000
// 621355968000000000
// 621355968000000000
// 637450559995600000
//c.add(Calendar.MINUTE, 1)
//timeStamp = (c.getTimeInMillis() * 10000) + 621355968000000000 - 26586006500000
//timeStamp = (c.getTimeInMillis() * 10000) + 621355968010000000 - 26586006500000
//timeStamp = (c.getTimeInMillis() * 10000) + 621355968000000000 - 26586006500000
//timeStamp = (c.getTimeInMillis() * 10000)
//timeStamp = (c.getTimeInMillis() * 10000) + 621355968000000000 - 26586006500000
//timeStamp = (c.getTimeInMillis() * 10000) + 662132938200000000
//timeStamp = (c.getTimeInMillis() * 10000) + 621355824000000000

//timeStamp = (c.getTimeInMillis() * 10000);

//log.info(String.valueOf(startTimeStamp))

//c.add(Calendar.MINUTE, 1)
//timeStamp = (c.getTimeInMillis() * 10000) + 621355968010000000 - 26586006500000
//log.info(&quot;WWWWWWWWWW&quot;);
//log.info(String.valueOf(timeStamp));
//
//c.add(Calendar.MINUTE, 1)
//timeStamp = (c.getTimeInMillis() * 10000) + 621355968010000000 - 26586006500000
//log.info(&quot;WWWWWWWWWW&quot;);
//log.info(String.valueOf(timeStamp));
//
//c.add(Calendar.MINUTE, 1)
//timeStamp = (c.getTimeInMillis() * 10000) + 621355968010000000 - 26586006500000
//log.info(&quot;WWWWWWWWWW&quot;);
//log.info(String.valueOf(timeStamp));
//
//c.add(Calendar.MINUTE, 1)
//timeStamp = (c.getTimeInMillis() * 10000) + 621355968010000000 - 26586006500000
//log.info(&quot;WWWWWWWWWW&quot;);
//log.info(String.valueOf(timeStamp));
//

//c.add(Calendar.MINUTE, 1)
//timeStamp = startTimeStamp + 621328950000000000
//log.info(&quot;WWWWWWWWWW&quot;);
//log.info(String.valueOf(timeStamp));

//startTimeStamp = 637450560600000000;

//startTimeStamp = 638029684200000000;

//timeStamp = startTimeStamp + incTicks;

//timeStamp = startTimeStamp;

//1 week = 10080 minutes
//1 month = 43800 minutes
//1 year = 525960 minutes

// 31700000 seconds in an year

randomValue = new Random();

BigInteger timeStamp = 0;
BigInteger startTimeStamp = 0;
BigInteger curStartTimeMillisLocVar = 0;
BigInteger curEndTimeMillisLocVar = 0;
//BigInteger incTicks = 600000000;

BigInteger[] timeTickArray = new BigInteger[31];
//startTimeStamp = (c.getTimeInMillis() * 10000) + 621355968000000000 - 26586006500000;

// to add in set call
//timeTickArray[0] = (setCal.getTimeInMillis() * 10000) + 621355968000000000 - 26586006500000;
timeTickArray[0] = (setCal.getTimeInMillis() * 10000) + 621355968000000000 - 26586006500000;

for (int i = 1;i&lt;31;++i)
{
	setCal.add(Calendar.SECOND, 20);
	timeTickArray[i] = (setCal.getTimeInMillis() * 10000) + 621355968000000000 - 26586006500000;
	//log.info(String.valueOf(timeTickArray[i]));
}


def String str = &quot;&quot;;


def String str1 = &apos;{&quot;collectionType&quot;: &quot;Online&quot;,&quot;dataStream&quot;:&quot;Live&quot;,&quot;triggerType&quot;: &quot;Trend&quot;,&quot;sampleSets&quot;:[&apos;;

def String str2 = &quot;&quot;;

def String sampleSetStr = &quot;&quot;;

def String str3 = &quot;]}&quot;;

//def Integer curGroupNum = 1;
def Integer curGroupNum = ctx.getThreadGroup().getNumberOfThreads();
def String curGroupStr = String.valueOf(curGroupNum);

// i is the number of minutes
//for (long i=1;i&lt;=10;++i){
//	log.info(&quot;*****I I I i i i ******&quot;);
//	log.info(String.valueOf(i));
//	log.info(&quot;thread(${__threadNum})&quot;)
//	timeStamp = startTimeStamp + 621328950000000000 + (i*590429952)

//timeStamp = (c.getTimeInMillis() * 10000) + 621355968000000000

// startTimeStamp = 637450560600000000
// incTicks = 600000000

//if(i==1){
//	timeStamp = startTimeStamp;
//}
//else{
//timeStamp = timeStamp + incTicks;
//}

//timeStamp = startTimeStamp + (i*600000000);

//log.info(String.valueOf(i));
//log.info(String.valueOf(timeStamp));


//c.add(Calendar.MINUTE, 1)



//
//c.add(Calendar.MINUTE, 1)
//timeStamp = timeStamp + 
//log.info(&quot;WWWWWWWWWW&quot;);
//log.info(String.valueOf(timeStamp));

//c.add(Calendar.MINUTE, 1)
//timeStamp = startTimeStamp + 621328950000000000 + 590429952
//log.info(&quot;WWWWWWWWWW&quot;);
//log.info(String.valueOf(timeStamp));
//
//c.add(Calendar.MINUTE, 1)
//timeStamp = startTimeStamp + 621328950000000000 +590429952 + 590429952
//timeStamp = startTimeStamp + 621328950000000000 + 2*(590429952)
////timeStamp = timeStamp+ 590429952
//log.info(&quot;WWWWWWWWWW&quot;);
//log.info(String.valueOf(timeStamp));

//c.add(Calendar.MINUTE, 1)
//timeStamp = startTimeStamp + 621328950000000000 +  590429952 + 590429952 + 590429952
//timeStamp = startTimeStamp + 621328950000000000 +  3*(590429952)
//log.info(&quot;WWWWWWWWWW&quot;);
//log.info(String.valueOf(timeStamp));

//c.add(Calendar.MINUTE, 1)
//timeStamp = startTimeStamp + 621328950000000000 + 590429952 + 590429952 + 590429952 + 590429952
//log.info(&quot;WWWWWWWWWW&quot;);
//log.info(String.valueOf(timeStamp));
//
////c.add(Calendar.MINUTE, 1)
//timeStamp = startTimeStamp + 621328950000000000 + 590429952 + 590429952 + 590429952 + 590429952 + 590429952
//log.info(&quot;WWWWWWWWWW&quot;);
//log.info(String.valueOf(timeStamp));

//String testPlanFile = GuiPackage.getInstance().getTestPlanFile();
//String testPlanFileDir = FilenameUtils.getFullPathNoEndSeparator(testPlanFile);

/*
 String groupName = ctx.getThreadGroup().getName();
log.info(groupName);
 */

/* 
  ${__threadGroupName} works fine to fetch Thread group
 */

 /*
  By default you can get the current sampler&apos;s name and current thread group&apos;s name using the following in-built JMeter functions

Current thread group name -&gt; ${__threadGroupName}

Current sampler name -&gt; ${__samplerName()}

Within the sampler name function you can store it into a variable and reuse it in subsequent places

${__samplerName(previousSamplerName)}
  */

//def path = FileServer.getFileServer().getBaseDir();
//def separator = File.separator;

//String fileName = &quot;tags.csv&quot;;
//String fileName = &quot;Offline_Tags_1.csv&quot;;
//def fileContents = new File(path+separator+fileName);
//def lines = fileContents.readLines()

//
//println &quot;************* size ********************* &quot;+lines.size()

//if(lines.size() &gt;= NumberOfTagsPerRequest)
//
////for(int TagCounter = 0;TagCounter&lt;NumberOfTagsPerRequest;TagCounter++) {
//for(int TagCounter = 1;TagCounter&lt;=NumberOfTagsPerRequest;TagCounter++) {
//println &quot;************* size ********************* &quot;+lines.get(TagCounter)
//
//	def SS = new SampleSet()		
//	
//	SS.tagId =lines.get(TagCounter)
//	SS.sampleType =&quot;StaticDataSample&quot;
//	SS.samples = new ArrayList&lt;SampleData&gt;()
//
//		
//	for(int SampleCounter = 0;SampleCounter&lt;NumberOfSamplesPerRequest;SampleCounter++) {
//		
//		def SD = new SampleData()
//		c.add(Calendar.MINUTE, 1)
//		SD.timeStamp = (c.getTimeInMillis() * 10000) + 621355968000000000
//		SD.dataStatus =0
//		SD.nodeStatus =0
//		SD.value=org.apache.commons.lang3.RandomUtils.nextInt(1, 1000)
//		
//		SS.samples &lt;&lt; SD
//	
//	}
//	data.SampleSets &lt;&lt; SS
//	
//}

//fileContents.eachLine { line -&gt;
//
//	def SS = new SampleSet()		
//	
//	SS.tagId =line
//	SS.sampleType =&quot;StaticDataSample&quot;
//	SS.samples = new ArrayList&lt;SampleData&gt;()
//
//		
//	for(int SampleCounter = 0;SampleCounter&lt;NumberOfSamplesPerRequest;SampleCounter++) {
//		
//		def SD = new SampleData()
//		c.add(Calendar.MINUTE, 1)
//		SD.timeStamp = (c.getTimeInMillis() * 10000) + 621355968000000000
//		SD.dataStatus =0
//		SD.nodeStatus =0
//		SD.value=org.apache.commons.lang3.RandomUtils.nextInt(1, 1000)
//		
//		SS.samples &lt;&lt; SD
//	
//	}
//	data.SampleSets &lt;&lt; SS
//	
//}


//def PayloadJson = JsonOutput.toJson(data)

//def str = &apos;{
//    &quot;collectionType&quot;: &quot;Offline&quot;,
//    &quot;dataStream&quot;: &quot;Live&quot;,
//    &quot;triggerType&quot;: &quot;Trend&quot;,
//    &quot;sampleSets&quot;: [
//        {
//            &quot;tagId&quot;: &quot;Offline_Tag_456-new-groupid-perfaz&quot;,
//            &quot;samples&quot;: [
//                {
//                    &quot;timeStamp&quot;: 637771539000000000,
//                    &quot;dataStatus&quot;: 0,
//                    &quot;nodeStatus&quot;: 0,
//                    &quot;value&quot;: 12.05
//                }
//            ],
//            &quot;sampleType&quot;: &quot;StaticDataSample&quot;
//        }
//    ]
//}&apos;
//def str = &apos;{&quot;ABC&quot;:{&quot;total&quot;:0,&quot;failed&quot;:0,&quot;skipped&quot;:0}}], [{&quot;BCD&quot;: {&quot;total&quot;:0,&quot;failed&quot;:0,&quot;skipped&quot;:0}}&apos;																	


//for(int i=0;i&lt;100;++i)
//{

//	def tagIdStr = args[0]
//	log.info(&quot;************* TAGID ********************* &quot;+tagIdStr)					
//	def str =&apos;{&quot;collectionType&quot;: &quot;Offline&quot;,&quot;dataStream&quot;: &quot;Live&quot;,&quot;triggerType&quot;: &quot;Trend&quot;,&quot;sampleSets&quot;: [{&quot;tagId&quot;: &quot;Offline_tag_1500&quot;,&quot;samples&quot;: [{&quot;timeStamp&quot;: 637771539000000000,&quot;dataStatus&quot;: 0,&quot;nodeStatus&quot;: 0,&quot;value&quot;: 12.05 }],&quot;sampleType&quot;: &quot;StaticDataSample&quot; }]}&apos;


//   long startPoint, endPoint = 0;
//   startPoint = 1;
//
//   if(thrNumberOnly==1){
//   	startPoint=1;
//   	endPoint=1000;
//   }
//   else{
//   	startPoint = ((thrNumberOnly-1)*1000)+1;
//   	endPoint = thrNumberOnly*1000;
//   }
//
//for(long k=startTi;k&lt;=endTime;++k)

//def String[] s1Tags = new String[]{ &quot;c46286c4-dba3-4490-8140-db3ee51553a5&quot;,
//        &quot;09e22d44-6928-4f24-9a30-9e2e79592f5c&quot;,
//        &quot;320a9173-7181-48a7-a996-1498e8506424&quot;,
//        &quot;d9695dbf-f268-4628-9322-82360e9b8ee2&quot;,
//        &quot;787e4dfb-7713-41ac-9f4f-a1702b3478a5&quot;,
//        &quot;ce8e0191-d48a-438a-94d5-2492d736cce3&quot;,
//        &quot;a993ab2f-7224-457b-b85e-4955229fd05a&quot;,
//        &quot;625a2b61-fbc0-4213-b4b0-7b48808b482e&quot;,
//        &quot;4fbdc846-c733-452b-9b68-366ae9596022&quot;,
//        &quot;fe7700aa-ba43-4c05-8f6b-2bee1c5d4181&quot;,
//        &quot;4aad531c-52d0-4901-9033-1fd52ce69215&quot;,
//        &quot;901d9028-2336-4673-beb6-503f05dacb20&quot;,
//        &quot;55d8f896-7514-4a9e-8416-ae7d83b9f6ad&quot;,
//        &quot;62b485f6-9ad6-499f-aaef-476a1940159f&quot;,
//        &quot;a085883d-c1a8-4d39-8885-dfab2fc53e13&quot;,
//        &quot;adeb8e0f-9a6c-4a57-818c-1a0499eb311a&quot;,
//        &quot;920afeb4-59b3-4b03-8903-d82b7f334009&quot;,
//        &quot;68b2912b-628c-4a09-b648-f2601b4626c4&quot;,
//        &quot;719ebb2e-70c7-4434-8b55-2f39c42f210f&quot;,
//        &quot;de13be47-6c5c-46ef-a172-a83ec214cb08&quot;,
//        &quot;14d9928b-a7bc-4846-b8bc-981311d4f076&quot;,
//        &quot;5346db48-d495-4f39-b9ad-8581b862f9b8&quot;,
//        &quot;bd7d7bdb-da66-4f16-9e8d-d43020ac46b4&quot;,
//        &quot;bfaa2892-18bb-4eaa-8edd-f6d18e5c6098&quot;,
//        &quot;f4ea522a-6ac7-4808-9445-e566c5695b18&quot;,
//        &quot;b9a7cb36-cb6a-4a1c-ba4d-9e47c06f6d1d&quot;,
//        &quot;815edff5-4dee-468d-bb5a-a0297d418481&quot;,
//        &quot;ba8da6a0-0071-4d65-adb6-fd52368edba8&quot;,
//        &quot;a291f630-ea37-4efd-8cb1-b5dd2a551e80&quot;,
//        &quot;6778d905-f421-4d70-b0f1-a611346b69e1&quot;,
//        &quot;58c14adb-41e5-41c0-9a8d-a7daf98b282d&quot;,
//        &quot;944d8df5-05d1-4950-a8ab-c7b79cc2592d&quot;,
//        &quot;7d7d3fb6-28ff-4f96-8dec-1b3dcac49077&quot;,
//        &quot;dbdbbb14-d06c-4a3a-a58b-eea752d84a30&quot;,
//        &quot;fa10b422-5acc-4c2a-899f-7eecb719e201&quot;,
//        &quot;9c4c573f-ed67-48bd-ac44-02c7f54a6d89&quot;,
//        &quot;13f5b1b9-ad33-44a1-a2ec-8f9033c72393&quot;,
//        &quot;b4694b0c-5680-4609-8d5b-bd6d7948bd08&quot;,
//        &quot;05ac1fe8-e8b5-4c03-9aaf-c5337f311449&quot;,
//        &quot;b8b1002d-3299-4baa-b962-3b6f694a9570&quot;,
//        &quot;5014cbec-1741-45f3-8a08-58f6958cca14&quot;,
//        &quot;9c142494-f6e6-49b4-be6c-950dce5e81de&quot;,
//        &quot;9c349c2f-1fc5-4cdc-bd89-3a02af5b14fa&quot;,
//        &quot;05bb48d7-888b-4007-b0f3-1ee701fb44a2&quot;,
//        &quot;bcc8d48b-2877-4f27-a78d-8dca96cfe8fa&quot;,
//        &quot;b41fdf1d-eaba-4c2e-a939-009eb4ceff7a&quot;,
//        &quot;7c309df8-b4ea-48ce-ac91-3f484130aab0&quot;,
//        &quot;c97dae2e-8e85-44eb-8ae8-b60bbc2137d2&quot;,
//        &quot;03ca3577-20e9-4d4c-b0b7-682bb5f02483&quot;,
//        &quot;d3a54e06-6e55-4618-a9b0-6e2efd40fe2d&quot;,
//        &quot;d1d3eed3-4ba6-485e-8b30-c71aab19de6b&quot;,
//        &quot;a300dcb1-0184-4d33-9b5c-e4bdc46c98b2&quot;,
//        &quot;301295f4-5d8b-4757-ae46-5d15465bde7b&quot;,
//        &quot;97798347-f7fb-45fc-9c83-4e92412c4933&quot;,
//        &quot;b01d670d-7af5-405b-a178-730a778c8b75&quot;,
//        &quot;27ee7424-fd8c-42e0-8786-ca5e0d0be5f2&quot;,
//        &quot;77b6e356-a3da-4f6b-b5f5-2a4a22d0e60d&quot;,
//        &quot;573f1f0f-92d5-4a80-920c-f69210ea122d&quot;,
//        &quot;bd0bd38e-3f5c-412e-8e8a-b3727e6f1a9e&quot;,
//        &quot;3784e04b-5469-4abe-8ed0-e374bd7593c5&quot;,
//        &quot;c9718bdb-cc8a-4134-9db2-fa1b74a529f3&quot;,
//        &quot;35054124-83e4-4b35-9b07-9d9ef185d283&quot;,
//        &quot;3e9af2e9-96cf-4c3a-8721-6ade808d40f4&quot;,
//        &quot;5dfa0f43-62ab-4e1a-916f-4216334ddc04&quot;,
//        &quot;e11dcbf3-11a8-4d10-a14e-541052f1177c&quot;,
//        &quot;f2d06212-7441-4d64-a720-4fe39992af37&quot;,
//        &quot;2c90c20b-3610-4bde-8357-40e742ec856b&quot;,
//        &quot;c58da1af-9273-44d2-932a-336ea486b9f4&quot;,
//        &quot;7ae97c3e-d29d-4db5-ba27-df414e4715d8&quot;,
//        &quot;0a5c1e0d-d8b2-4554-b38b-8cf77e73b5fb&quot;,
//        &quot;12f1fcae-674a-4ae2-bfe9-686ad4b63c03&quot;,
//        &quot;3eb996f4-311e-4a2b-9b7c-9818efb09091&quot;,
//        &quot;ab4da6e7-27aa-40ac-a40f-bd7da7c8f161&quot;,
//        &quot;5b3c250d-34d2-408a-b72b-0e50804290d2&quot;,
//        &quot;1ce491ab-34c8-4759-8d2c-a867f401edc2&quot;,
//        &quot;07440499-4ab3-4a48-ba04-29035ca2a379&quot;,
//        &quot;b850e43f-94c0-4e58-8877-5532003d0a60&quot;,
//        &quot;85a5b0a0-600a-4679-827d-a34f2d46f709&quot;,
//        &quot;f5b105a2-d7c3-489c-a2b7-725702ef608e&quot;,
//        &quot;2cf66532-6cd0-4ba3-8800-77baff9e23b2&quot;,
//        &quot;8b62925b-fa33-45f3-bd35-cb7ec2ef9e1b&quot;,
//        &quot;6e1d8787-6f25-4c55-a709-f3b9bc6728e5&quot;,
//        &quot;d16857f8-d6d4-4146-82a9-009e9a745af4&quot;,
//        &quot;ec806cad-d8f5-4d27-8c4f-f66fa6c9dbcb&quot;,
//        &quot;5b664c4c-474d-476f-ba5e-a92d42f23a8d&quot;,
//        &quot;a5f7e668-89b5-4fb9-ae96-d8d0560dd8ff&quot;,
//        &quot;2b1ec795-418c-4f9d-93ba-ad863c3a54f4&quot;,
//        &quot;c323672b-e843-45c1-a396-8e9fe3f763d4&quot;,
//        &quot;79e85f80-6ab6-4e63-b022-dd0acf288a72&quot;,
//        &quot;103fc40c-d550-472a-a66e-8b8c95a48825&quot;,
//        &quot;ebefd223-4d5d-4086-9e78-39913d3852d9&quot;,
//        &quot;dee62802-ed69-4ffe-ac61-14f420df04f3&quot;,
//        &quot;68eb4867-fcf2-4cc1-82cb-0af2c47d9236&quot;,
//        &quot;83885713-3405-4748-9341-4bd6072778b1&quot;,
//        &quot;b253b75d-f4a1-46e6-b5e5-e7d5f5030f08&quot;,
//        &quot;09e36e42-2f4a-4256-be1f-06b3d226baac&quot;,
//        &quot;637aa470-3731-45a1-be66-351d655e1722&quot;,
//        &quot;e9f1e910-9a6c-49fc-b639-bffca27fc8b9&quot;,
//        &quot;cc21caae-83d0-4c7c-bd67-1f54e876d212&quot;,
//        &quot;1ac9d16a-15cb-4fc1-8f74-73dd8148c8b1&quot;,
//        &quot;0e225e9a-8378-4b23-8ab5-c9093204ac25&quot;,
//        &quot;ea2edbf0-00c1-4a67-aa33-1384af5ada3f&quot;,
//        &quot;28e685d1-5584-4731-bcf5-1fcfe8d4f248&quot;,
//        &quot;1db79d1d-4eec-4723-8356-e2e5f75a05d1&quot;,
//        &quot;73381ab7-5a3e-4527-80d0-03883eed1709&quot;,
//        &quot;eb7fd3ce-4524-4763-9864-795a8acf2f47&quot;,
//        &quot;6b7db810-7cd0-4716-b879-f93b03ea0f30&quot;,
//        &quot;22bddfe4-4cb0-4c40-a3cc-76f48cb6f574&quot;,
//        &quot;08156387-bcc5-431f-9701-e281eb33a4fd&quot;,
//        &quot;97ec0332-112c-4670-9a8a-f712881f8365&quot;,
//        &quot;ea84d8a1-46e3-4ca8-b11e-4fa6a4b0dcc8&quot;,
//        &quot;d82aafdc-c3f6-42b8-8cb9-b29735f384e1&quot;,
//        &quot;2f31e09a-b00e-477c-8b9a-d20cee0e9631&quot;,
//        &quot;4a6f3831-f66f-4722-aaf5-a42856c26dac&quot;,
//        &quot;0698153a-cd1b-40a7-a08a-966155baa733&quot;,
//        &quot;588b0b59-371c-4b8c-a8b5-9648ea70cb70&quot;,
//        &quot;30e3a854-5922-4050-bf13-3dc318675ce9&quot;,
//        &quot;55858664-ed7e-435e-aead-3f67dfff650b&quot;,
//        &quot;ef2b5023-918e-4514-a8ce-a4d147dc5f5a&quot;,
//        &quot;ed52f1a8-9c78-4662-aada-5a06c22783a1&quot;,
//        &quot;3d95d0f5-c9f3-4c5f-a52f-05f868724a3e&quot;,
//        &quot;75d288e7-5efd-4bfc-b10f-db7d089445dd&quot;,
//        &quot;e13c3b8f-e415-4960-aaab-06e15f42b58c&quot;,
//        &quot;aeb9620e-6589-45a1-ad20-0bd9ab607259&quot;,
//        &quot;1cfe24f3-e250-4aae-8ac9-49da85b298fe&quot;,
//        &quot;ffaa34a9-02db-4e31-a804-41b28b919556&quot;,
//        &quot;2bf1373a-0c12-47db-b803-b2b010634013&quot;,
//        &quot;e9698636-49c5-4841-97e7-2c8bfa480aa6&quot;,
//        &quot;a6af5f9e-9bfb-46f4-bc2e-055ec954867a&quot;,
//        &quot;682bbeb7-ec5d-414d-8ab8-077a566359d4&quot;,
//        &quot;05c3d4e3-9dfd-47fc-b659-d7a658be36d7&quot;,
//        &quot;ffd8485a-d6ea-473e-b88f-f4ef07cebbc0&quot;,
//        &quot;6e1fc9e7-4581-4c6a-8d46-e094b7997540&quot;,
//        &quot;5f071c7c-9af4-4018-8bdd-39c0c262f452&quot;,
//        &quot;d6276f27-50e5-48ba-8731-bc8643617d71&quot;,
//        &quot;972f5b55-2665-4878-836b-4cbb100215a6&quot;,
//        &quot;b1b8180a-f9fa-41a5-ab54-81cca3dd71e9&quot;,
//        &quot;97de28e5-0ffa-420e-a32f-3ab93eca70aa&quot;,
//        &quot;601b07ab-c162-4f52-8034-0fad15d8f9e2&quot;,
//        &quot;5fefc998-8447-46b6-bb2f-90cec9e590d6&quot;,
//        &quot;79e08468-d5c1-461e-a4ff-513fbdca407a&quot;,
//        &quot;55e83d75-5efc-4c2a-8df4-38b9c30405dd&quot;,
//        &quot;55fbe4ac-3177-4473-ab17-f82483d4f100&quot;,
//        &quot;bde476cc-8186-4c23-84c2-83f09be4cf16&quot;,
//        &quot;8b58262d-df18-48ec-b793-74f05bdba333&quot;,
//        &quot;e12a07cd-d768-4b2c-815e-ee0cc7cdc127&quot;,
//        &quot;3ec07eaf-2fe1-46e6-adef-a00f2a443900&quot;,
//        &quot;ba45d339-4fa7-47c9-b6ca-7990c18c89e7&quot;,
//        &quot;bc904057-3405-4200-a8fd-0f1baaf9dadb&quot;,
//        &quot;04764837-66d6-433a-ad5d-84c2257d2532&quot;,
//        &quot;bab98d03-bca1-47a5-a35b-f38688ffe62b&quot;,
//        &quot;e03e8618-0ce1-46b6-8c77-e416c85aea09&quot;,
//        &quot;7419e617-c128-4a7b-9a28-6b8d8573f90d&quot;,
//        &quot;1feb6a1d-eb1b-40e4-85ac-52268d7e9cd3&quot;,
//        &quot;6bd0ae7d-c6d6-44a7-8c06-0955178831c0&quot;,
//        &quot;f3780e24-90b9-4ae1-a60b-fdcea3db76ca&quot;,
//        &quot;4358ed39-b76d-4a2d-8b6e-80af8eb3b4e8&quot;,
//        &quot;ae8bd8ce-24ec-4b4c-855a-3530b4566130&quot;,
//        &quot;e46b205e-ed52-4499-ba3d-5b5b0a0afe18&quot;,
//        &quot;1b83e4ca-1d93-4afe-9deb-fad61e6400d2&quot;,
//        &quot;7aef158c-420d-496c-9ff3-cf0b5479c4bc&quot;,
//        &quot;2136794b-af00-450f-9da9-a9b31ca6b5c8&quot;,
//        &quot;8b67ab2d-73cc-42ce-bf87-d1eea6e24583&quot;,
//        &quot;af91d7a0-90a4-4375-8114-ac817f614ddb&quot;,
//        &quot;f27bd514-d94b-4585-8a77-f1963a01136a&quot;,
//        &quot;b1fb64f0-6a15-4272-a1e5-3beaa83885f7&quot;,
//        &quot;e534dc78-0819-4d7b-ade2-ef3937e103a2&quot;,
//        &quot;a476fd37-f8b6-4db0-b354-4ce334e21be4&quot;,
//        &quot;8ae170c5-5b2d-4f12-b577-c83f3ed9efbe&quot;,
//        &quot;5a98d0b6-2066-4c10-b0ea-d6d8e6fb158e&quot;,
//        &quot;264fea98-a022-491a-bd93-04cfc548cca3&quot;,
//        &quot;87ee50be-4782-4243-a4dd-1ff36b915c46&quot;,
//        &quot;44b55d3b-ff4f-429a-a164-1df3bb68b5e2&quot;,
//        &quot;fe639c89-fa98-4085-99b7-9355b811722e&quot;,
//        &quot;931357d5-8d8e-4d3c-abc5-2b2eab1b121d&quot;,
//        &quot;f52409aa-b4a8-45df-b633-9c8e3689bc7d&quot;,
//        &quot;28f59baf-eb3c-4d09-84a6-0ea28e817db8&quot;,
//        &quot;22a029f7-9d14-4bb4-bc3b-c2e27af1f073&quot;,
//        &quot;dfebe931-d2af-4093-8b8d-1b7ab96ae523&quot;,
//        &quot;dff43723-d864-4f66-ae49-21c02c3e736c&quot;,
//        &quot;dbf23a3a-1d93-421c-9da1-5468e7230215&quot;,
//        &quot;6803bbd0-16a4-478d-a061-de5b1be1f32e&quot;,
//        &quot;708aa6a4-c715-440b-b3d5-232c5eaa532a&quot;,
//        &quot;9e56958e-b592-46a0-8ad4-1af3d557c9f4&quot;,
//        &quot;6baffd55-b523-4fb1-a7ab-63e3bfcfd475&quot;,
//        &quot;505be2ee-a422-4101-8e71-fe220d3fd9f5&quot;,
//        &quot;7a10ab58-b727-4a51-8c53-9d8b3b0bce28&quot;,
//        &quot;abfedb7e-6c40-4475-badf-54c2bdc1e666&quot;,
//        &quot;2295b5f4-a54a-4e53-8c60-181fc61554fa&quot;,
//        &quot;45649ca3-7281-4cca-b2ea-4406f9dcb830&quot;,
//        &quot;7302c22b-9c15-4f1a-9505-8f6b1be90d4e&quot;,
//        &quot;91192f2a-35ed-4fa9-a8fc-a5eec4f202cb&quot;,
//        &quot;fe0bc320-3aab-412d-8fe3-9862f5d1bcca&quot;,
//        &quot;25abe2e8-3e98-4563-ba89-7a5a310c7417&quot;,
//        &quot;96157eb4-b95f-47bd-969c-4eaf45f98255&quot;,
//        &quot;61f9955b-42d5-47c7-9b6f-083a934082b7&quot;,
//        &quot;46fefb4f-e65d-4d4e-afbb-ff8abd8ba084&quot;,
//        &quot;cb505c49-d5b0-4d7b-af47-29d80f09d02d&quot;,
//        &quot;c0a50e9a-6f4a-46a9-a554-33e8d4715329&quot;,
//        &quot;416dda69-d232-4085-8153-fbc3347c9eb1&quot;,
//        &quot;7519eb18-2047-4941-8942-71cafd135e5a&quot;,
//        &quot;e1e9e7e7-6e08-428c-9800-1c8f712becf7&quot;,
//        &quot;e099ccd0-ab04-4563-8716-556807f60fb9&quot;,
//        &quot;c3598683-894c-4550-a31b-f9a3a1289145&quot;,
//        &quot;5ce510ff-5725-4d53-8114-78c5f240e6c5&quot;,
//        &quot;f8ca0451-b12e-4bf8-bb74-072541576a30&quot;,
//        &quot;d930c051-5c95-444b-b3c0-22d9645d2e4e&quot;,
//        &quot;86b366cf-801f-40d6-a046-a3d9d32380df&quot;,
//        &quot;5b2c4df5-5b6f-455b-8640-a747ec25debe&quot;,
//        &quot;266dd9df-33a7-40c8-b443-6ec8b53a8fe5&quot;,
//        &quot;ca700a14-9591-46fc-8300-5ec6488d01e1&quot;,
//        &quot;41979a2f-43e1-48c6-9245-332ef0f676d8&quot;,
//        &quot;3f5130f0-29aa-4943-b285-d9e06e1e0848&quot;,
//        &quot;ab18a3e4-eb8f-40f2-ba98-9f2ddfa3b9fe&quot;,
//        &quot;cecf6ffd-223c-4a1b-b168-576ba7d3b452&quot;,
//        &quot;bd2afc40-db8d-4fbd-96fa-42dc0a7759fa&quot;,
//        &quot;d3f8660f-16b1-4109-a173-54d1953c1540&quot;,
//        &quot;34d8312a-6275-4c6f-9525-4bcefa6acb71&quot;,
//        &quot;72432d07-693e-4a81-9d93-fa20c5cf0d70&quot;,
//        &quot;72180d20-6c76-465f-aa92-886277244b7d&quot;,
//        &quot;50c50bdc-71ee-45c8-97c4-136ed57e4987&quot;,
//        &quot;1f0c0c1b-1a19-4a0d-8ae5-28823823f8af&quot;,
//        &quot;68ca4678-be45-4c6d-b311-def9f4cde0e4&quot;,
//        &quot;db4d934c-d433-47f1-9321-97d61f8b6723&quot;,
//        &quot;4b7be3af-2857-4fb1-8c91-afed60e2bfba&quot;,
//        &quot;aff091ee-f67f-4d25-9fd0-66259cade7db&quot;,
//        &quot;161733c1-b72d-4643-ab4b-231cf0dcd5b5&quot;,
//        &quot;2d3adc1e-6093-4b4f-9af6-d24efc55faf0&quot;,
//        &quot;6257b92e-4bb1-43ec-bc0b-5d646f4f7a14&quot;,
//        &quot;120d74bd-f420-4399-a9f7-a6cfa5adad41&quot;,
//        &quot;594f4a0d-ee44-4a50-aa6e-1bf272abb347&quot;,
//        &quot;b7a2a724-fb57-4aee-bb97-60e975fbe0c5&quot;,
//        &quot;93e28af6-2842-4d36-8123-151ea8bc53a2&quot;,
//        &quot;c22ae091-84cf-4db2-b041-9718e89316da&quot;,
//        &quot;65683923-73ea-4814-94e2-6f2b13f17875&quot;,
//        &quot;ff027ea0-0b0f-4cc0-b55c-08713a3afaf7&quot;,
//        &quot;f135eff3-62c8-4ad7-a306-f1e5652dc676&quot;,
//        &quot;fd327f62-b286-4e6f-8776-121ae1da7e12&quot;,
//        &quot;56c5ee68-185c-4654-9b73-b05e0f77285a&quot;,
//        &quot;4b527c83-f45b-4493-8081-6cc6be5b72e9&quot;,
//        &quot;1d6df5c2-9dbd-4ca4-b2ca-64f058735c6e&quot;,
//        &quot;08b7accf-d019-4dae-a3e7-254c3799ce19&quot;,
//        &quot;e4c80ccc-89ed-4216-b644-753d57907130&quot;,
//        &quot;3c89741c-6567-44a1-b502-a833042dc25d&quot;,
//        &quot;6891e229-2a9b-4fe7-8cc5-01ac00b7852f&quot;,
//        &quot;623ef234-c48a-4a93-ba3e-4c1e4d89ccf4&quot;,
//        &quot;14cfa815-c30d-41e8-bd58-388dc94e31dc&quot;,
//        &quot;5129b591-779f-4f01-8f49-052271d4e4e1&quot;,
//        &quot;0b977e0d-9b45-4763-8f7c-1950121724f8&quot;,
//        &quot;5f35e899-073b-4fda-91f5-2194f61d2ab6&quot;,
//        &quot;ea314408-434f-43f2-9f60-dbae2186caad&quot;,
//        &quot;ecacd87d-fa21-45d1-b237-44255ab49c88&quot;,
//        &quot;2c10eaf4-b4e1-4a92-ab9f-e2deec9d3433&quot;,
//        &quot;d69a4729-4286-47a3-a391-16d1d4cdd5b6&quot;,
//        &quot;f0a7574f-c826-4eba-ad94-da63922edc3c&quot;,
//        &quot;a62388b9-c3f2-4ebc-89aa-ab7a985f0801&quot;,
//        &quot;bba13ae3-301f-4f92-a777-56ed323754cc&quot;,
//        &quot;b83b89cb-ccd9-434e-9dea-1160df29e640&quot;,
//        &quot;4378b739-e04b-45fe-96aa-442780158e07&quot;,
//        &quot;19bbabe2-0420-4e16-93e0-0aaaba5ef6f9&quot;,
//        &quot;41973c86-b30f-4c8e-9daf-c95449576e13&quot;,
//        &quot;638f093c-03da-4986-a287-9db3bdca7430&quot;,
//        &quot;52eaf1ad-5d9e-459e-84c4-2936e3c1b07c&quot;,
//        &quot;70450c0c-7993-41c6-a825-9537ca8f86b9&quot;,
//        &quot;4a73a1ed-a9d3-4a97-989e-7f9521a04008&quot;,
//        &quot;4cdd036f-d579-4892-a7b9-027869d62a7a&quot;,
//        &quot;d9f3cec4-0987-4d1f-bc4e-e38f25922f08&quot;,
//        &quot;e49005f0-01dd-4052-9490-1845a4dc7086&quot;,
//        &quot;ad5b8992-8c3b-4e6a-b7d1-fb68a46baf96&quot;,
//        &quot;e00b6aec-dd9c-4d43-bdca-3bd2bc265775&quot;,
//        &quot;749c9641-eaf5-4996-80ae-db6b37679ef1&quot;,
//        &quot;d682073e-59ff-4f80-9473-7755b4ef1880&quot;,
//        &quot;89f684a7-d658-4ee9-a0c0-0c92186c0b13&quot;,
//        &quot;6ff22381-92ce-48aa-ba72-76ccae9220e4&quot;,
//        &quot;60c2349e-9afa-4cba-b390-cca0748edefc&quot;,
//        &quot;b0bacb98-e2f5-4d88-859c-f962d5e8f6af&quot;,
//        &quot;ae586cb6-765e-4e83-baaf-17c029a0e83d&quot;,
//        &quot;a57be8fa-fc11-413e-b3c0-16c477875123&quot;,
//        &quot;f03138c1-03a9-4af1-8883-2115c5b57168&quot;,
//        &quot;afc417ab-0275-4fbc-a1d1-a7e24681a926&quot;,
//        &quot;ecc179bc-b12f-4586-8eaf-8c96a4a2cee0&quot;,
//        &quot;d0d898a5-bea6-41a1-b69c-1ab5fff16834&quot;,
//        &quot;75e3214e-06c4-46ae-b649-e9b3d232c034&quot;,
//        &quot;a54c0ba4-2aa0-4c82-b013-1831db458d30&quot;,
//        &quot;cce25bc6-82af-4957-8f6b-50499ed88dd1&quot;,
//        &quot;6cb5a182-d4a9-45f3-94e8-66f7cde79500&quot;,
//        &quot;00d15a07-6489-4846-9210-c53a3386d86d&quot;,
//        &quot;a6c52b37-07c3-49da-af62-e3ea2147da66&quot;,
//        &quot;b28dc7a0-a5fd-4094-ab3e-c310167e381c&quot;,
//        &quot;b7791795-58c7-49f5-ba80-235458e4bb62&quot;,
//        &quot;92122098-ab09-4971-8d8d-0d34b45b6bd9&quot;,
//        &quot;11477f09-06a9-4542-b9c6-1542439b4367&quot;,
//        &quot;5b6b3672-7e2c-4b01-bb96-d032e980b2b6&quot;,
//        &quot;d762a0eb-6d3e-43c0-bc00-f653b3c30465&quot;,
//        &quot;f5057e1a-ad3c-4567-9dde-717b552e819a&quot;,
//        &quot;a42026fd-51d5-4606-a5e3-9bdd2ac37af7&quot;,
//        &quot;ee1b1e9f-f6ec-4e9b-8467-531039c5386b&quot;,
//        &quot;af3e913d-908a-4fe1-ad9b-592314e19884&quot;,
//        &quot;d04ba367-abaf-4f9e-8841-afc092695896&quot;,
//        &quot;3835a97f-4716-4358-bd28-9a7bbb772661&quot;};

//   strThrNum=&quot;thread(${__threadNum})&quot;;
//   String thrNumberOnly= strThrNum.replaceAll(&quot;[^0-9]&quot;, &quot;&quot;);
//   log.info(&quot;-------------------&quot;);
//   log.info(strThrNum);

//int curThrNum = Integer.parseInt(thrNumberOnly);


//   
//   log.info(String.valueOf(thrNumberOnly));
//   log.info(String.valueOf(curThrNum));

//   int startPoint, endPoint = 0;
//   startPoint = 1;
//
//   if(curThrNum==1){
//   	startPoint=1;
//   	endPoint=1000;
//   }
//   else{
//   	startPoint = ((curThrNum-1)*1000)+1;
//   	endPoint = curThrNum*1000;
//   }

   // for 5000 tags scenario: startPoint = ((curThrNum-5)*1000)+1;

//   log.info(&quot;START END POINTS&quot;);
//
//log.info(String.valueOf(startPoint));
//log.info(&quot;pppp&quot;);
//log.info(String.valueOf(endPoint));


//random case which casued memory issue: replacing it with only ONE Group ID only for 300 tags in below loop:
// Random intRan = new Random();
//int ranStart = intRan.nextInt(98000);
//ranStart = ranStart+1;
//int ranEnd = ranStart+300;





//j means number of tags
//[need to take 300 tags], we started setting it in late october/november so would be better to start from september


//1st iteration, 1st group tags
//2nd iteration, 2ng group tags
//and so on... till 100th
//every group we take 1st 300 tags

for(int j = 1;j&lt;=300;++j){

def ranInt = randomValue.nextInt(90);
//log.info(&quot;RANDOM INT&quot;);
//log.info(String.valueOf(ranInt));
	
//	log.info(&quot;***J J J value j j j***\n&quot;);
//	log.info(String.valueOf(j));
//	log.info(&quot;thread(${__threadNum})&quot;)

//	String strThrNum = &quot;&quot;;

//   String str2=&quot;thread(99908)&quot;;
//   String numberOnly= str2.replaceAll(&quot;[^0-9]&quot;, &quot;&quot;);
//
//  strThrNum=&quot;thread(${__threadNum})&quot;;
//  String thrNumberOnly= strThrNum.replaceAll(&quot;[^0-9]&quot;, &quot;&quot;);
//   log.info(&quot;-------------------&quot;);
//   log.info(strThrNum);
//   log.info(thrNumberOnly);


//   log.info(&quot;START END POINTS&quot;);
//
//log.info(String.valueOf(startPoint));
//log.info(&quot;**********&quot;);
//log.info(String.valueOf(endPoint));
//log.info(&quot;**********&quot;);
//
//log.info(&quot;***VALUE OF J*******&quot;);
//log.info(String.valueOf(j));
//log.info(&quot;**********&quot;);
//log.info(&quot;****ENDS******&quot;);

//	str = &apos;{&quot;collectionType&quot;: &quot;Online&quot;,&quot;dataStream&quot;: &quot;Live&quot;,&quot;triggerType&quot;: &quot;Trend&quot;,&quot;sampleSets&quot;: [{&quot;tagId&quot;: &quot;&apos; + tagIdStr + &apos;&quot;,&quot;samples&quot;: [{&quot;timeStamp&quot;: 637771539000000000,&quot;dataStatus&quot;: 0,&quot;nodeStatus&quot;: 0,&quot;value&quot;: 12.05 }],&quot;sampleType&quot;: &quot;StaticDataSample&quot; }]}&apos;
//

//str = &apos;{&quot;tagIds&quot;: [&quot;&apos;+tagIdStr+&apos;&quot;],&quot;startTime&quot;: 637451064600000000,&quot;endTime&quot;: 637908299170000000,&quot;summaryTypes&quot;: [&quot;MinValue&quot;,&quot;MaxValue&quot;],&quot;triggerTypeProportions&quot;: {&quot;Trend&quot;: &quot;60&quot;,&quot;Alarm&quot;: &quot;30&quot;,&quot;Transient&quot;: &quot;10&quot;},&quot;maxNumberOfSamplesPerTag&quot;: 50, &quot;requestedStatusBits&quot;: 0, &quot;associatedTagIds&quot;: { }}&apos;

//	str = &apos;{    &quot;collectionType&quot;: &quot;Online&quot;,&quot;dataStream&quot;:&quot;Live&quot;,&quot;triggerType&quot;: &quot;Trend&quot;,&quot;sampleSets&quot;:[{ &quot;tagId&quot;: &quot;Online_Tag_&quot;,&apos;+j+&apos;            &quot;samples&quot;: [ {                    &quot;value&quot;: 0,                    &quot;nodeStatus&quot;: 0,                    &quot;timeStamp&quot;: 637450560000000000,                    &quot;dataStatus&quot;: 0                },                {                    &quot;value&quot;: 1,                    &quot;nodeStatus&quot;: 0,                    &quot;timeStamp&quot;: 637450560600000000,                    &quot;dataStatus&quot;: 0                },                {                    &quot;value&quot;: 2,                    &quot;nodeStatus&quot;: 0,                    &quot;timeStamp&quot;: 637450561200000000,                    &quot;dataStatus&quot;: 0                }      ],            &quot;sampleType&quot;: &quot;StaticDataSample&quot;        }    ]}&apos;

//old working str:
//str = &apos;{    &quot;collectionType&quot;: &quot;Online&quot;,&quot;dataStream&quot;:&quot;Live&quot;,&quot;triggerType&quot;: &quot;Trend&quot;,&quot;sampleSets&quot;:[{ &quot;tagId&quot;: &quot;Online_Tag_&apos;+j+&apos;&quot;, &quot;samples&quot;: [{&quot;value&quot;: 123,&quot;nodeStatus&quot;: 0, &quot;timeStamp&quot;: &apos;+ timeStamp +&apos;,&quot;dataStatus&quot;: 0}],&quot;sampleType&quot;: &quot;StaticDataSample&quot;}]}&apos;

//create tag str:
//tempStr = &quot;{\&quot;Id\&quot;:\&quot;PerfTest5NoPIData5Us_&quot;+curThrNum+&quot;_&quot;+j+&quot;\&quot;,\&quot;Name\&quot;:\&quot;PerfTest5NoPIData5Us_&quot;+curThrNum+&quot;_&quot;+j+&quot;\&quot;,\&quot;Description\&quot;:\&quot;AmbientPressure\&quot;,\&quot;GroupId\&quot;:\&quot;S1E2C-PROTO4\&quot;,\&quot;CollectionType\&quot;:\&quot;Offline\&quot;,\&quot;DataType\&quot;:\&quot;Float64\&quot;,\&quot;StorageClass\&quot;:[\&quot;Raw\&quot;,\&quot;Tiered\&quot;],\&quot;Unit\&quot;:null,\&quot;SubUnit\&quot;:null,\&quot;DataSourceType\&quot;:\&quot;PI\&quot;},&quot;;

//old 300 same group tags:
//sampleSetStr=&apos;{ &quot;tagId&quot;: &quot;Online_TagLongv_&apos;+j+&apos;&quot;, &quot;Samples&quot;: [{\&quot;value\&quot;:60.0,\&quot;dataStatus\&quot;:0,\&quot;nodeStatus\&quot;:0,\&quot;timeStamp\&quot;:&apos;+timeTickArray[0]+&apos;},{\&quot;value\&quot;:&apos;+String.valueOf(randomValue.nextInt(90))+&apos;,\&quot;dataStatus\&quot;:0,\&quot;nodeStatus\&quot;:0,\&quot;timeStamp\&quot;:&apos;+timeTickArray[1]+&apos;},{\&quot;value\&quot;:&apos;+S


sampleSetStr=&apos;{ &quot;tagId&quot;: &quot;RelTestPERF_AWS_5APR23_OfflineTag_&apos;+j+&apos;_G_&apos;+curGroupNum+&apos;&quot;, &quot;Samples&quot;: [{\&quot;value\&quot;:60.0,\&quot;dataStatus\&quot;:0,\&quot;nodeStatus\&quot;:0,\&quot;timeStamp\&quot;:&apos;+timeTickArray[0]+&apos;},{\&quot;value\&quot;:&apos;+String.valueOf(randomValue.nextInt(90))+&apos;,\&quot;dataStatus\&quot;:0,\&quot;nodeStatus\&quot;:0,\&quot;timeStamp\&quot;:&apos;+timeTickArray[1]+&apos;},{\&quot;value\&quot;:&apos;+String.valueOf(randomValue.nextInt(90))+&apos;,\&quot;dataStatus\&quot;:0,\&quot;nodeStatus\&quot;:0,\&quot;timeStamp\&quot;:&apos;+timeTickArray[2]+&apos;},{\&quot;value\&quot;:&apos;+String.valueOf(randomValue.nextInt(90))+&apos;,\&quot;dataStatus\&quot;:0,\&quot;nodeStatus\&quot;:0,\&quot;timeStamp\&quot;:&apos;+timeTickArray[3]+&apos;},{\&quot;value\&quot;:&apos;+String.valueOf(randomValue.nextInt(90))+&apos;,\&quot;dataStatus\&quot;:0,\&quot;nodeStatus\&quot;:0,\&quot;timeStamp\&quot;:&apos;+timeTickArray[4]+&apos;},{\&quot;value\&quot;:&apos;+String.valueOf(randomValue.nextInt(90))+&apos;,\&quot;dataStatus\&quot;:0,\&quot;nodeStatus\&quot;:0,\&quot;timeStamp\&quot;:&apos;+timeTickArray[5]+&apos;},{\&quot;value\&quot;:&apos;+String.valueOf(randomValue.nextInt(90))+&apos;,\&quot;dataStatus\&quot;:0,\&quot;nodeStatus\&quot;:0,\&quot;timeStamp\&quot;:&apos;+timeTickArray[6]+&apos;},{\&quot;value\&quot;:&apos;+String.valueOf(randomValue.nextInt(90))+&apos;,\&quot;dataStatus\&quot;:0,\&quot;nodeStatus\&quot;:0,\&quot;timeStamp\&quot;:&apos;+timeTickArray[7]+&apos;},{\&quot;value\&quot;:&apos;+String.valueOf(randomValue.nextInt(90))+&apos;,\&quot;dataStatus\&quot;:0,\&quot;nodeStatus\&quot;:0,\&quot;timeStamp\&quot;:&apos;+timeTickArray[8]+&apos;},{\&quot;value\&quot;:&apos;+String.valueOf(randomValue.nextInt(90))+&apos;,\&quot;dataStatus\&quot;:0,\&quot;nodeStatus\&quot;:0,\&quot;timeStamp\&quot;:&apos;+timeTickArray[9]+&apos;},{\&quot;value\&quot;:&apos;+String.valueOf(randomValue.nextInt(90))+&apos;,\&quot;dataStatus\&quot;:0,\&quot;nodeStatus\&quot;:0,\&quot;timeStamp\&quot;:&apos;+timeTickArray[10]+&apos;},{\&quot;value\&quot;:&apos;+String.valueOf(randomValue.nextInt(90))+&apos;,\&quot;dataStatus\&quot;:0,\&quot;nodeStatus\&quot;:0,\&quot;timeStamp\&quot;:&apos;+timeTickArray[11]+&apos;},{\&quot;value\&quot;:&apos;+String.valueOf(randomValue.nextInt(90))+&apos;,\&quot;dataStatus\&quot;:0,\&quot;nodeStatus\&quot;:0,\&quot;timeStamp\&quot;:&apos;+timeTickArray[12]+&apos;},{\&quot;value\&quot;:&apos;+String.valueOf(randomValue.nextInt(90))+&apos;,\&quot;dataStatus\&quot;:0,\&quot;nodeStatus\&quot;:0,\&quot;timeStamp\&quot;:&apos;+timeTickArray[13]+&apos;},{\&quot;value\&quot;:&apos;+String.valueOf(randomValue.nextInt(90))+&apos;,\&quot;dataStatus\&quot;:0,\&quot;nodeStatus\&quot;:0,\&quot;timeStamp\&quot;:&apos;+timeTickArray[14]+&apos;},{\&quot;value\&quot;:&apos;+String.valueOf(randomValue.nextInt(90))+&apos;,\&quot;dataStatus\&quot;:0,\&quot;nodeStatus\&quot;:0,\&quot;timeStamp\&quot;:&apos;+timeTickArray[15]+&apos;},{\&quot;value\&quot;:&apos;+String.valueOf(randomValue.nextInt(90))+&apos;,\&quot;dataStatus\&quot;:0,\&quot;nodeStatus\&quot;:0,\&quot;timeStamp\&quot;:&apos;+timeTickArray[16]+&apos;},{\&quot;value\&quot;:&apos;+String.valueOf(randomValue.nextInt(90))+&apos;,\&quot;dataStatus\&quot;:0,\&quot;nodeStatus\&quot;:0,\&quot;timeStamp\&quot;:&apos;+timeTickArray[17]+&apos;},{\&quot;value\&quot;:&apos;+String.valueOf(randomValue.nextInt(90))+&apos;,\&quot;dataStatus\&quot;:0,\&quot;nodeStatus\&quot;:0,\&quot;timeStamp\&quot;:&apos;+timeTickArray[18]+&apos;},{\&quot;value\&quot;:&apos;+String.valueOf(randomValue.nextInt(90))+&apos;,\&quot;dataStatus\&quot;:0,\&quot;nodeStatus\&quot;:0,\&quot;timeStamp\&quot;:&apos;+timeTickArray[19]+&apos;},{\&quot;value\&quot;:&apos;+String.valueOf(randomValue.nextInt(90))+&apos;,\&quot;dataStatus\&quot;:0,\&quot;nodeStatus\&quot;:0,\&quot;timeStamp\&quot;:&apos;+timeTickArray[20]+&apos;},{\&quot;value\&quot;:&apos;+String.valueOf(randomValue.nextInt(90))+&apos;,\&quot;dataStatus\&quot;:0,\&quot;nodeStatus\&quot;:0,\&quot;timeStamp\&quot;:&apos;+timeTickArray[21]+&apos;},{\&quot;value\&quot;:&apos;+String.valueOf(randomValue.nextInt(90))+&apos;,\&quot;dataStatus\&quot;:0,\&quot;nodeStatus\&quot;:0,\&quot;timeStamp\&quot;:&apos;+timeTickArray[22]+&apos;},{\&quot;value\&quot;:&apos;+String.valueOf(randomValue.nextInt(90))+&apos;,\&quot;dataStatus\&quot;:0,\&quot;nodeStatus\&quot;:0,\&quot;timeStamp\&quot;:&apos;+timeTickArray[23]+&apos;},{\&quot;value\&quot;:&apos;+String.valueOf(randomValue.nextInt(90))+&apos;,\&quot;dataStatus\&quot;:0,\&quot;nodeStatus\&quot;:0,\&quot;timeStamp\&quot;:&apos;+timeTickArray[24]+&apos;},{\&quot;value\&quot;:&apos;+String.valueOf(randomValue.nextInt(90))+&apos;,\&quot;dataStatus\&quot;:0,\&quot;nodeStatus\&quot;:0,\&quot;timeStamp\&quot;:&apos;+timeTickArray[25]+&apos;},{\&quot;value\&quot;:&apos;+String.valueOf(randomValue.nextInt(90))+&apos;,\&quot;dataStatus\&quot;:0,\&quot;nodeStatus\&quot;:0,\&quot;timeStamp\&quot;:&apos;+timeTickArray[26]+&apos;},{\&quot;value\&quot;:&apos;+String.valueOf(randomValue.nextInt(90))+&apos;,\&quot;dataStatus\&quot;:0,\&quot;nodeStatus\&quot;:0,\&quot;timeStamp\&quot;:&apos;+timeTickArray[27]+&apos;},{\&quot;value\&quot;:&apos;+String.valueOf(randomValue.nextInt(90))+&apos;,\&quot;dataStatus\&quot;:0,\&quot;nodeStatus\&quot;:0,\&quot;timeStamp\&quot;:&apos;+timeTickArray[28]+&apos;},{\&quot;value\&quot;:&apos;+String.valueOf(randomValue.nextInt(90))+&apos;,\&quot;dataStatus\&quot;:0,\&quot;nodeStatus\&quot;:0,\&quot;timeStamp\&quot;:&apos;+timeTickArray[29]+&apos;}], &quot;sampleType&quot;: &quot;StaticDataSample&quot;},&apos;;




str2 = str2+sampleSetStr;

}


str = str1+str2+str3;



	
	//def parser = new JsonSlurper()
	//def json = parser.parseText(str)
	
	//vars.put(&quot;Payload&quot;, PayloadJson)
	//vars.put(&quot;Payload&quot;, json)
	//log.info(&quot;************* JSON SLURPER  ********************* &quot;+vars.get(&quot;Payload&quot;))


	
	vars.put(&quot;Payload&quot;, str);
	
	log.info(&quot;SET DATA CALL NO. :&quot;+String.valueOf(vars.getIteration())+&quot; ENDS&quot;);
//	log.info(&quot;************* Set Data ********************* &quot;+vars.get(&quot;Payload&quot;))
	
//}


	
	//println &quot;************* create tag ********************* &quot;+vars.get(&quot;Payload&quot;)
//	log.info(&quot;************* Set Data ********************* &quot;+vars.get(&quot;Payload&quot;))
	
	//println &quot;************* create tag ********************* &quot;+vars.get(&quot;Payload&quot;)
	//log.info(&quot;************* Set Data ********************* &quot;+vars.get(&quot;Payload&quot;))
//}
</stringProp>
          </JSR223PreProcessor>
          <hashTree/>
          <HeaderManager guiclass="HeaderPanel" testclass="HeaderManager" testname="HTTP Header Manager" enabled="true">
            <collectionProp name="HeaderManager.headers">
              <elementProp name="" elementType="Header">
                <stringProp name="Header.name">tenantID</stringProp>
                <stringProp name="Header.value">${tenant}</stringProp>
              </elementProp>
              <elementProp name="" elementType="Header">
                <stringProp name="Header.name">Content-Type</stringProp>
                <stringProp name="Header.value">application/json</stringProp>
              </elementProp>
              <elementProp name="Authorization" elementType="Header">
                <stringProp name="Header.name">Authorization</stringProp>
                <stringProp name="Header.value">Bearer ${access_token}</stringProp>
              </elementProp>
            </collectionProp>
          </HeaderManager>
          <hashTree/>
          <ResponseAssertion guiclass="AssertionGui" testclass="ResponseAssertion" testname="Response Assertion" enabled="true">
            <collectionProp name="Asserion.test_strings">
              <stringProp name="49586">200</stringProp>
            </collectionProp>
            <stringProp name="Assertion.custom_message"></stringProp>
            <stringProp name="Assertion.test_field">Assertion.response_code</stringProp>
            <boolProp name="Assertion.assume_success">false</boolProp>
            <intProp name="Assertion.test_type">16</intProp>
          </ResponseAssertion>
          <hashTree/>
        </hashTree>
        <JSR223Sampler guiclass="TestBeanGUI" testclass="JSR223Sampler" testname="Set Online PG Data Api Body" enabled="false">
          <stringProp name="cacheKey">true</stringProp>
          <stringProp name="filename"></stringProp>
          <stringProp name="parameters"></stringProp>
          <stringProp name="script">import groovy.json.*

// NEED TO REFER THE SetOnlineData Payload Generator [Code already there, just need to split it cleanly].

String groupIdStr = &quot;&quot;;

// Will need to add one line to read group id, can get it through a row in csv. Or maybe, we can add a separate cell for s1,pi,pg

if(&quot;S1&quot;){groupIdStr = &quot;&quot;;} 
else if(&quot;PI&quot;){groupIdStr = &quot;&quot;;}
else if(&quot;PG&quot;){groupIdStr = &quot;&quot;;}

String str1 = &quot;{&quot;;
String str2 = groupIdStr;
String str3 = &quot;\&quot;tagIds\&quot;:&quot;;
String str4 = String.valueOf(quotesTagsForReq);
String str5 = &quot;,\&quot;startTimes\&quot;:&quot;;
String str6 = String.valueOf(listOfStartTimes);
String str7 = &quot;,\&quot;endTime\&quot;:&quot;+String.valueOf(endTimeStamp);
String str8 = &quot;,\&quot;TriggerType\&quot;: \&quot;Trend\&quot;,\&quot;maxNumberOfSamplesPerTag\&quot;: 2,\&quot;requestedStatusBits\&quot;: 0,\&quot;associatedTagIds\&quot;: {}&quot;;
String str9 = &quot;}&quot;;



String fetchRawCallBody = str1+str2+str3+str4+str5+str6+str7+str8+str9;
log.info(String.valueOf(fetchRawCallBody));

vars.put(&quot;Payload_FetchRaw&quot;, fetchRawCallBody);


</stringProp>
          <stringProp name="scriptLanguage">groovy</stringProp>
        </JSR223Sampler>
        <hashTree/>
        <JSR223Sampler guiclass="TestBeanGUI" testclass="JSR223Sampler" testname="Set Offline PG Data Api Body" enabled="false">
          <stringProp name="cacheKey">true</stringProp>
          <stringProp name="filename"></stringProp>
          <stringProp name="parameters"></stringProp>
          <stringProp name="script">import groovy.json.*

// NEED TO REFER THE SetOnlineData Payload Generator [Code already there, just need to split it cleanly].

String groupIdStr = &quot;&quot;;

// Will need to add one line to read group id, can get it through a row in csv. Or maybe, we can add a separate cell for s1,pi,pg

if(&quot;S1&quot;){groupIdStr = &quot;&quot;;} 
else if(&quot;PI&quot;){groupIdStr = &quot;&quot;;}
else if(&quot;PG&quot;){groupIdStr = &quot;&quot;;}

String str1 = &quot;{&quot;;
String str2 = groupIdStr;
String str3 = &quot;\&quot;tagIds\&quot;:&quot;;
String str4 = String.valueOf(quotesTagsForReq);
String str5 = &quot;,\&quot;startTimes\&quot;:&quot;;
String str6 = String.valueOf(listOfStartTimes);
String str7 = &quot;,\&quot;endTime\&quot;:&quot;+String.valueOf(endTimeStamp);
String str8 = &quot;,\&quot;TriggerType\&quot;: \&quot;Trend\&quot;,\&quot;maxNumberOfSamplesPerTag\&quot;: 2,\&quot;requestedStatusBits\&quot;: 0,\&quot;associatedTagIds\&quot;: {}&quot;;
String str9 = &quot;}&quot;;



String fetchRawCallBody = str1+str2+str3+str4+str5+str6+str7+str8+str9;
log.info(String.valueOf(fetchRawCallBody));

vars.put(&quot;Payload_FetchRaw&quot;, fetchRawCallBody);


</stringProp>
          <stringProp name="scriptLanguage">groovy</stringProp>
        </JSR223Sampler>
        <hashTree/>
        <HTTPSamplerProxy guiclass="HttpTestSampleGui" testclass="HTTPSamplerProxy" testname="PG Fetch Summary Data Request" enabled="false">
          <boolProp name="HTTPSampler.postBodyRaw">true</boolProp>
          <elementProp name="HTTPsampler.Arguments" elementType="Arguments">
            <collectionProp name="Arguments.arguments">
              <elementProp name="" elementType="HTTPArgument">
                <boolProp name="HTTPArgument.always_encode">false</boolProp>
                <stringProp name="Argument.value">${Payload_FetchSummary}</stringProp>
                <stringProp name="Argument.metadata">=</stringProp>
              </elementProp>
            </collectionProp>
          </elementProp>
          <stringProp name="HTTPSampler.domain">${AppURL}</stringProp>
          <stringProp name="HTTPSampler.port"></stringProp>
          <stringProp name="HTTPSampler.protocol">https</stringProp>
          <stringProp name="HTTPSampler.contentEncoding"></stringProp>
          <stringProp name="HTTPSampler.path">/timeseries/v1/query/data/raw</stringProp>
          <stringProp name="HTTPSampler.method">POST</stringProp>
          <boolProp name="HTTPSampler.follow_redirects">true</boolProp>
          <boolProp name="HTTPSampler.auto_redirects">false</boolProp>
          <boolProp name="HTTPSampler.use_keepalive">true</boolProp>
          <boolProp name="HTTPSampler.DO_MULTIPART_POST">false</boolProp>
          <stringProp name="HTTPSampler.embedded_url_re"></stringProp>
          <stringProp name="HTTPSampler.connect_timeout"></stringProp>
          <stringProp name="HTTPSampler.response_timeout"></stringProp>
        </HTTPSamplerProxy>
        <hashTree>
          <HeaderManager guiclass="HeaderPanel" testclass="HeaderManager" testname="HTTP Header Manager" enabled="true">
            <collectionProp name="HeaderManager.headers">
              <elementProp name="tenantID" elementType="Header">
                <stringProp name="Header.name">tenantID</stringProp>
                <stringProp name="Header.value">S1Enterprise</stringProp>
              </elementProp>
              <elementProp name="Authorization" elementType="Header">
                <stringProp name="Header.name">Authorization</stringProp>
                <stringProp name="Header.value">Bearer ${access_token}</stringProp>
              </elementProp>
              <elementProp name="Content-Type" elementType="Header">
                <stringProp name="Header.name">Content-Type</stringProp>
                <stringProp name="Header.value">application/json</stringProp>
              </elementProp>
            </collectionProp>
          </HeaderManager>
          <hashTree/>
          <ResponseAssertion guiclass="AssertionGui" testclass="ResponseAssertion" testname="Response Assertion" enabled="true">
            <collectionProp name="Asserion.test_strings">
              <stringProp name="49586">200</stringProp>
            </collectionProp>
            <stringProp name="Assertion.custom_message"></stringProp>
            <stringProp name="Assertion.test_field">Assertion.response_code</stringProp>
            <boolProp name="Assertion.assume_success">false</boolProp>
            <intProp name="Assertion.test_type">16</intProp>
          </ResponseAssertion>
          <hashTree/>
        </hashTree>
        <HTTPSamplerProxy guiclass="HttpTestSampleGui" testclass="HTTPSamplerProxy" testname="Set Online PG Data Request" enabled="false">
          <boolProp name="HTTPSampler.postBodyRaw">true</boolProp>
          <elementProp name="HTTPsampler.Arguments" elementType="Arguments">
            <collectionProp name="Arguments.arguments">
              <elementProp name="" elementType="HTTPArgument">
                <boolProp name="HTTPArgument.always_encode">false</boolProp>
                <stringProp name="Argument.value">${Payload_SetDataOnline}</stringProp>
                <stringProp name="Argument.metadata">=</stringProp>
              </elementProp>
            </collectionProp>
          </elementProp>
          <stringProp name="HTTPSampler.domain">${AppURL}</stringProp>
          <stringProp name="HTTPSampler.port"></stringProp>
          <stringProp name="HTTPSampler.protocol">https</stringProp>
          <stringProp name="HTTPSampler.contentEncoding"></stringProp>
          <stringProp name="HTTPSampler.path">/timeseries/v1/query/data/raw</stringProp>
          <stringProp name="HTTPSampler.method">POST</stringProp>
          <boolProp name="HTTPSampler.follow_redirects">true</boolProp>
          <boolProp name="HTTPSampler.auto_redirects">false</boolProp>
          <boolProp name="HTTPSampler.use_keepalive">true</boolProp>
          <boolProp name="HTTPSampler.DO_MULTIPART_POST">false</boolProp>
          <stringProp name="HTTPSampler.embedded_url_re"></stringProp>
          <stringProp name="HTTPSampler.connect_timeout"></stringProp>
          <stringProp name="HTTPSampler.response_timeout"></stringProp>
        </HTTPSamplerProxy>
        <hashTree>
          <HeaderManager guiclass="HeaderPanel" testclass="HeaderManager" testname="HTTP Header Manager" enabled="true">
            <collectionProp name="HeaderManager.headers">
              <elementProp name="tenantID" elementType="Header">
                <stringProp name="Header.name">tenantID</stringProp>
                <stringProp name="Header.value">S1Enterprise</stringProp>
              </elementProp>
              <elementProp name="Authorization" elementType="Header">
                <stringProp name="Header.name">Authorization</stringProp>
                <stringProp name="Header.value">Bearer ${access_token}</stringProp>
              </elementProp>
              <elementProp name="Content-Type" elementType="Header">
                <stringProp name="Header.name">Content-Type</stringProp>
                <stringProp name="Header.value">application/json</stringProp>
              </elementProp>
            </collectionProp>
          </HeaderManager>
          <hashTree/>
          <ResponseAssertion guiclass="AssertionGui" testclass="ResponseAssertion" testname="Response Assertion" enabled="true">
            <collectionProp name="Asserion.test_strings">
              <stringProp name="49586">200</stringProp>
            </collectionProp>
            <stringProp name="Assertion.custom_message"></stringProp>
            <stringProp name="Assertion.test_field">Assertion.response_code</stringProp>
            <boolProp name="Assertion.assume_success">false</boolProp>
            <intProp name="Assertion.test_type">16</intProp>
          </ResponseAssertion>
          <hashTree/>
        </hashTree>
        <HTTPSamplerProxy guiclass="HttpTestSampleGui" testclass="HTTPSamplerProxy" testname="Set Offline PG Data Request" enabled="false">
          <boolProp name="HTTPSampler.postBodyRaw">true</boolProp>
          <elementProp name="HTTPsampler.Arguments" elementType="Arguments">
            <collectionProp name="Arguments.arguments">
              <elementProp name="" elementType="HTTPArgument">
                <boolProp name="HTTPArgument.always_encode">false</boolProp>
                <stringProp name="Argument.value">${Payload_SetDataOffline}</stringProp>
                <stringProp name="Argument.metadata">=</stringProp>
              </elementProp>
            </collectionProp>
          </elementProp>
          <stringProp name="HTTPSampler.domain">${AppURL}</stringProp>
          <stringProp name="HTTPSampler.port"></stringProp>
          <stringProp name="HTTPSampler.protocol">https</stringProp>
          <stringProp name="HTTPSampler.contentEncoding"></stringProp>
          <stringProp name="HTTPSampler.path">/timeseries/v1/query/data/raw</stringProp>
          <stringProp name="HTTPSampler.method">POST</stringProp>
          <boolProp name="HTTPSampler.follow_redirects">true</boolProp>
          <boolProp name="HTTPSampler.auto_redirects">false</boolProp>
          <boolProp name="HTTPSampler.use_keepalive">true</boolProp>
          <boolProp name="HTTPSampler.DO_MULTIPART_POST">false</boolProp>
          <stringProp name="HTTPSampler.embedded_url_re"></stringProp>
          <stringProp name="HTTPSampler.connect_timeout"></stringProp>
          <stringProp name="HTTPSampler.response_timeout"></stringProp>
        </HTTPSamplerProxy>
        <hashTree>
          <HeaderManager guiclass="HeaderPanel" testclass="HeaderManager" testname="HTTP Header Manager" enabled="true">
            <collectionProp name="HeaderManager.headers">
              <elementProp name="tenantID" elementType="Header">
                <stringProp name="Header.name">tenantID</stringProp>
                <stringProp name="Header.value">S1Enterprise</stringProp>
              </elementProp>
              <elementProp name="Authorization" elementType="Header">
                <stringProp name="Header.name">Authorization</stringProp>
                <stringProp name="Header.value">Bearer ${access_token}</stringProp>
              </elementProp>
              <elementProp name="Content-Type" elementType="Header">
                <stringProp name="Header.name">Content-Type</stringProp>
                <stringProp name="Header.value">application/json</stringProp>
              </elementProp>
            </collectionProp>
          </HeaderManager>
          <hashTree/>
          <ResponseAssertion guiclass="AssertionGui" testclass="ResponseAssertion" testname="Response Assertion" enabled="true">
            <collectionProp name="Asserion.test_strings">
              <stringProp name="49586">200</stringProp>
            </collectionProp>
            <stringProp name="Assertion.custom_message"></stringProp>
            <stringProp name="Assertion.test_field">Assertion.response_code</stringProp>
            <boolProp name="Assertion.assume_success">false</boolProp>
            <intProp name="Assertion.test_type">16</intProp>
          </ResponseAssertion>
          <hashTree/>
        </hashTree>
        <JSR223Sampler guiclass="TestBeanGUI" testclass="JSR223Sampler" testname="BACKUP - Fetch Raw - JSR223 Sampler - BACKUP" enabled="false">
          <stringProp name="cacheKey">true</stringProp>
          <stringProp name="filename"></stringProp>
          <stringProp name="parameters"></stringProp>
          <stringProp name="script">import groovy.json.*

tenantSpecTagsFile = new File(&quot;C:/AllJmeterScriptsBackup/AllJmeterScriptsBackup/refactoredCsvRead_april25/refactored/TenantData2/&quot;+vars.get(&quot;Tenant_Id&quot;)+&quot;.csv&quot;)

//def csv_content = fh.getText(&apos;utf-8&apos;)
//log.info(csv_content)

class FileHelper {
    static eachLineInRange(File file, IntRange lineRange, Closure closure) {
        file.withReader { r-&gt;
            def line
            for(; (line = r.readLine()) != null;) {
                def lineNo = r.lineNumber
                if(lineNo &lt; lineRange.from) continue
                if(lineNo &gt; lineRange.to) break
                closure.call(line, lineNo)
            }
        }
    }
}

//Integer start = vars.get(&quot;Start_Id&quot;);
//Integer end = vars.get(&quot;End_Id&quot;);


def lineList = []
String[] tagList;
//String[] tagsForRequestBody;
def tagsForRequestBody = [];
//	def tagList = []


	
use(FileHelper) {

tenantSpecTagsFile.eachLineInRange(Integer.valueOf(vars.get(&quot;Start_Id&quot;))..Integer.valueOf(vars.get(&quot;End_Id&quot;))){line, lineNo -&gt;
//    tenantSpecTagsFile.eachLineInRange(1..300){line, lineNo -&gt;
//    tenantSpecTagsFile.eachLineInRange(start..end){line, lineNo -&gt;
        log.info (&quot;$line&quot;)
tagList = line.split(&apos;,&apos;)
int count=0;
  for( String values : tagList )
      if((count++)%2 != 0)
//      log.info(values);
tagsForRequestBody.add(values);
//        		lineList.add(line)

    }

}


log.info(String.valueOf(tagsForRequestBody));

def quotesTagsForReq = [];
//quotesTagsForReq = [&apos;&quot;&apos; + tagsName for tagsName in quotesTagsForReq];
for( String tagsName : tagsForRequestBody ){
 	quotesTagsForReq.add(&apos;&quot;&apos; + tagsName + &apos;&quot;&apos;);
 	}
log.info(String.valueOf(quotesTagsForReq));

//log.info(String.valueOf(lineList));


//def lineNoRange = 2..4
//def lineList = []
//myFile.eachLine { line, lineNo -&gt;
//	if(lineNoRange.contains(lineNo)){
//		lineList.add(line)
//	}
//}
//println &quot;lineList : $lineList&quot;



//use(FileHelper) {
//    tenantSpecTagsFile.eachLineInRange(Integer.valueOf(vars.get(&quot;Start_Id&quot;))..Integer.valueOf(vars.get(&quot;End_Id&quot;))){tagName, id -&gt;
////    tenantSpecTagsFile.eachLineInRange(1..300){line, lineNo -&gt;
////    tenantSpecTagsFile.eachLineInRange(start..end){line, lineNo -&gt;
//        log.info (&quot;$id) $tagName&quot;)
//    }
//}

//def f = &apos;/path/to/file&apos; as File
//use(FileHelper) {
//    f.eachLineInRange(from..to){line, lineNo -&gt;
//        println &quot;$lineNo) $line&quot;
//    }
//}


//take cur time
Calendar curTime = Calendar.getInstance();
//Long CUR_SET_StartTimeMillisLocVar = 0; //curTime.getTimeInMillis()
curTime.setTimeInMillis(curTime.getTimeInMillis()); 
//minus 11 minutes
curTime.add(Calendar.MINUTE, -11);

//CUR_SET_c.add(Calendar.MONTH, 1);
////CUR_SET_c.add(Calendar.DATE, 1);
//CUR_SET_c.add(Calendar.SECOND,-6);

//convert it to ticks
//that is the start time

TimeZone tz1 = curTime.getTimeZone();
int offsetFromUTC1 = tz1.getOffset(curTime.getTimeInMillis());
log.debug(&quot;offset is &quot; + offsetFromUTC1);

curTime.add(Calendar.MILLISECOND, offsetFromUTC1);

log.debug(&quot;Created GMT cal with date [&quot; + curTime.getTime() + &quot;]&quot;);

//vars.put(&quot;CUR_SET_START_TIME_MILLIS&quot;,String.valueOf(CUR_SET_StartTimeMillisLocVar)); 
//vars.put(&quot;curStartTimeMillis&quot;,String.valueOf(CUR_SET_StartTimeMillisLocVar));
//
//startTimeStamp = (CUR_SET_c.getTimeInMillis() * 10000) + 621355968000000000 - 26586006500000;
// 621355968000000000
Long startTimeStamp = 0;

startTimeStamp = (curTime.getTimeInMillis() * 10000) + 621355968000000000;
//or
//startTimeStamp = (CUR_SET_StartTimeMillisLocVar * 10000) + 621355968000000000 - 26586006500000;
//vars.put(&quot;curStartTimeMillis&quot;,String.valueOf(CUR_SET_StartTimeMillisLocVar));
//vars.put(&quot;currentStartTime&quot;,String.valueOf(startTimeStamp));

//then add 10 minutes
//convert it to ticks
//that is the end time

//endtimestamp
curTime.add(Calendar.MINUTE, 10);
// 621355968000000000
//endTimeStamp = (CUR_SET_c.getTimeInMillis() * 10000) + 621355968000000000 - 26586006500000;
Long endTimeStamp = 0;

endTimeStamp = (curTime.getTimeInMillis() * 10000) + 621355968000000000;
//vars.put(&quot;currentEndTime&quot;,String.valueOf(endTimeStamp));
//CUR_SET_EndTimeMillisLocVar = CUR_SET_c.getTimeInMillis();
//
//vars.put(&quot;curStartTimeMillis&quot;,String.valueOf(CUR_SET_StartTimeMillisLocVar));
//vars.put(&quot;curEndTimeMillis&quot;,String.valueOf(CUR_SET_EndTimeMillisLocVar));
//
//vars.put(&quot;currentStartTime&quot;, String.valueOf(startTimeStamp));
//vars.put(&quot;currentEndTime&quot;, String.valueOf(endTimeStamp));

//log.info(&quot;CURRENT START TIME MILLIS USER VARIABLE VALUE:&quot;);
//log.info(String.valueOf(vars.get(&quot;curStartTimeMillis&quot;)));
//
//log.info(&quot;CURRENT END TIME MILLIS USER VARIABLE VALUE:&quot;);
//log.info(String.valueOf(vars.get(&quot;curEndTimeMillis&quot;)));


///////


//count the num of tags there [by diff of startid and endid]
int numOfTags = Integer.valueOf(vars.get(&quot;End_Id&quot;)) - Integer.valueOf(vars.get(&quot;Start_Id&quot;)) + 1;
//run the loop that many times and create an array with starttimestamp that many times
def listOfStartTimes = [];
for (int i=1;i&lt;=numOfTags;++i){
	listOfStartTimes.add(startTimeStamp);
}
log.info(String.valueOf(listOfStartTimes));


String groupIdStr = &quot;&quot;;

// Will need to add one line to read group id, can get it through a row in csv. [easy]
if(&quot;S1&quot;){groupIdStr = &quot;&quot;;} 
else if(&quot;PI&quot;){groupIdStr = &quot;&quot;;}
else if(&quot;PG&quot;){groupIdStr = &quot;&quot;;}

String str1 = &quot;{&quot;;
String str2 = groupIdStr;
String str3 = &quot;\&quot;tagIds\&quot;:&quot;;
String str4 = String.valueOf(quotesTagsForReq);
String str5 = &quot;,\&quot;startTimes\&quot;:&quot;;
String str6 = String.valueOf(listOfStartTimes);
String str7 = &quot;,\&quot;endTime\&quot;:&quot;+String.valueOf(endTimeStamp);
String str8 = &quot;,\&quot;TriggerType\&quot;: \&quot;Trend\&quot;,\&quot;maxNumberOfSamplesPerTag\&quot;: 2,\&quot;requestedStatusBits\&quot;: 0,\&quot;associatedTagIds\&quot;: {}&quot;;
String str9 = &quot;}&quot;;



String fetchRawCallBody = str1+str2+str3+str4+str5+str6+str7+str8+str9;
log.info(String.valueOf(fetchRawCallBody));

vars.put(&quot;Payload_FetchRaw&quot;, fetchRawCallBody);


</stringProp>
          <stringProp name="scriptLanguage">groovy</stringProp>
        </JSR223Sampler>
        <hashTree/>
      </hashTree>
      <ThreadGroup guiclass="ThreadGroupGui" testclass="ThreadGroup" testname="SetTag" enabled="true">
        <stringProp name="ThreadGroup.on_sample_error">continue</stringProp>
        <elementProp name="ThreadGroup.main_controller" elementType="LoopController" guiclass="LoopControlPanel" testclass="LoopController" testname="Loop Controller" enabled="true">
          <boolProp name="LoopController.continue_forever">false</boolProp>
          <stringProp name="LoopController.loops">1</stringProp>
        </elementProp>
        <stringProp name="ThreadGroup.num_threads">1</stringProp>
        <stringProp name="ThreadGroup.ramp_time">1</stringProp>
        <boolProp name="ThreadGroup.scheduler">false</boolProp>
        <stringProp name="ThreadGroup.duration">86400</stringProp>
        <stringProp name="ThreadGroup.delay"></stringProp>
        <boolProp name="ThreadGroup.same_user_on_next_iteration">false</boolProp>
      </ThreadGroup>
      <hashTree>
        <CSVDataSet guiclass="TestBeanGUI" testclass="CSVDataSet" testname="Extract Runtime Configuration" enabled="false">
          <stringProp name="delimiter">,</stringProp>
          <stringProp name="fileEncoding"></stringProp>
          <stringProp name="filename">${tenantDriverCsvPath}</stringProp>
          <boolProp name="ignoreFirstLine">true</boolProp>
          <boolProp name="quotedData">false</boolProp>
          <boolProp name="recycle">false</boolProp>
          <stringProp name="shareMode">shareMode.all</stringProp>
          <boolProp name="stopThread">true</boolProp>
          <stringProp name="variableNames">Tenant_Id, Start_Id, End_Id</stringProp>
        </CSVDataSet>
        <hashTree/>
        <LoopController guiclass="LoopControlPanel" testclass="LoopController" testname="tenMinsBatch Loop Controller 1" enabled="true">
          <boolProp name="LoopController.continue_forever">true</boolProp>
          <stringProp name="LoopController.loops">2</stringProp>
        </LoopController>
        <hashTree>
          <CounterConfig guiclass="CounterConfigGui" testclass="CounterConfig" testname="tenMinsBatchCounter" enabled="true">
            <stringProp name="CounterConfig.start">0</stringProp>
            <stringProp name="CounterConfig.end">2</stringProp>
            <stringProp name="CounterConfig.incr">1</stringProp>
            <stringProp name="CounterConfig.name">tenMinsBatchCounter</stringProp>
            <stringProp name="CounterConfig.format"></stringProp>
            <boolProp name="CounterConfig.per_user">false</boolProp>
          </CounterConfig>
          <hashTree/>
          <LoopController guiclass="LoopControlPanel" testclass="LoopController" testname="groupNum Loop Controller 2" enabled="true">
            <boolProp name="LoopController.continue_forever">true</boolProp>
            <stringProp name="LoopController.loops">15</stringProp>
          </LoopController>
          <hashTree>
            <CounterConfig guiclass="CounterConfigGui" testclass="CounterConfig" testname="groupNumCounter" enabled="true">
              <stringProp name="CounterConfig.start">1</stringProp>
              <stringProp name="CounterConfig.end">15</stringProp>
              <stringProp name="CounterConfig.incr">1</stringProp>
              <stringProp name="CounterConfig.name">groupNumCounter</stringProp>
              <stringProp name="CounterConfig.format"></stringProp>
              <boolProp name="CounterConfig.per_user">false</boolProp>
            </CounterConfig>
            <hashTree/>
            <HTTPSamplerProxy guiclass="HttpTestSampleGui" testclass="HTTPSamplerProxy" testname="GenerateTenantToken" enabled="true">
              <elementProp name="HTTPsampler.Arguments" elementType="Arguments" guiclass="HTTPArgumentsPanel" testclass="Arguments" testname="User Defined Variables" enabled="true">
                <collectionProp name="Arguments.arguments">
                  <elementProp name="username" elementType="HTTPArgument">
                    <boolProp name="HTTPArgument.always_encode">false</boolProp>
                    <stringProp name="Argument.value">s1e-realm-admin</stringProp>
                    <stringProp name="Argument.metadata">=</stringProp>
                    <boolProp name="HTTPArgument.use_equals">true</boolProp>
                    <stringProp name="Argument.name">username</stringProp>
                  </elementProp>
                  <elementProp name="password" elementType="HTTPArgument">
                    <boolProp name="HTTPArgument.always_encode">false</boolProp>
                    <stringProp name="Argument.value">Test@123</stringProp>
                    <stringProp name="Argument.metadata">=</stringProp>
                    <boolProp name="HTTPArgument.use_equals">true</boolProp>
                    <stringProp name="Argument.name">password</stringProp>
                  </elementProp>
                  <elementProp name="client_id" elementType="HTTPArgument">
                    <boolProp name="HTTPArgument.always_encode">false</boolProp>
                    <stringProp name="Argument.value">app-appshell</stringProp>
                    <stringProp name="Argument.metadata">=</stringProp>
                    <boolProp name="HTTPArgument.use_equals">true</boolProp>
                    <stringProp name="Argument.name">client_id</stringProp>
                  </elementProp>
                  <elementProp name="grant_type" elementType="HTTPArgument">
                    <boolProp name="HTTPArgument.always_encode">false</boolProp>
                    <stringProp name="Argument.value">password</stringProp>
                    <stringProp name="Argument.metadata">=</stringProp>
                    <boolProp name="HTTPArgument.use_equals">true</boolProp>
                    <stringProp name="Argument.name">grant_type</stringProp>
                  </elementProp>
                  <elementProp name="client_secret" elementType="HTTPArgument">
                    <boolProp name="HTTPArgument.always_encode">false</boolProp>
                    <stringProp name="Argument.value">${client_secret}</stringProp>
                    <stringProp name="Argument.metadata">=</stringProp>
                    <boolProp name="HTTPArgument.use_equals">true</boolProp>
                    <stringProp name="Argument.name">client_secret</stringProp>
                  </elementProp>
                </collectionProp>
              </elementProp>
              <stringProp name="HTTPSampler.domain">${AuthURL}</stringProp>
              <stringProp name="HTTPSampler.port"></stringProp>
              <stringProp name="HTTPSampler.protocol">https</stringProp>
              <stringProp name="HTTPSampler.contentEncoding"></stringProp>
              <stringProp name="HTTPSampler.path">/auth/realms/S1E/protocol/openid-connect/token</stringProp>
              <stringProp name="HTTPSampler.method">POST</stringProp>
              <boolProp name="HTTPSampler.follow_redirects">true</boolProp>
              <boolProp name="HTTPSampler.auto_redirects">false</boolProp>
              <boolProp name="HTTPSampler.use_keepalive">true</boolProp>
              <boolProp name="HTTPSampler.DO_MULTIPART_POST">false</boolProp>
              <stringProp name="HTTPSampler.embedded_url_re"></stringProp>
              <stringProp name="HTTPSampler.connect_timeout"></stringProp>
              <stringProp name="HTTPSampler.response_timeout"></stringProp>
            </HTTPSamplerProxy>
            <hashTree>
              <SyncTimer guiclass="TestBeanGUI" testclass="SyncTimer" testname="Synchronizing Timer" enabled="true">
                <intProp name="groupSize">1</intProp>
                <longProp name="timeoutInMs">0</longProp>
              </SyncTimer>
              <hashTree/>
              <HeaderManager guiclass="HeaderPanel" testclass="HeaderManager" testname="HTTP Header Manager" enabled="true">
                <collectionProp name="HeaderManager.headers">
                  <elementProp name="" elementType="Header">
                    <stringProp name="Header.name">Content-Type</stringProp>
                    <stringProp name="Header.value">application/x-www-form-urlencoded</stringProp>
                  </elementProp>
                </collectionProp>
              </HeaderManager>
              <hashTree/>
              <JSONPostProcessor guiclass="JSONPostProcessorGui" testclass="JSONPostProcessor" testname="JSON Extractor" enabled="true">
                <stringProp name="JSONPostProcessor.referenceNames">token</stringProp>
                <stringProp name="JSONPostProcessor.jsonPathExprs">access_token</stringProp>
                <stringProp name="JSONPostProcessor.match_numbers"></stringProp>
              </JSONPostProcessor>
              <hashTree/>
              <BeanShellAssertion guiclass="BeanShellAssertionGui" testclass="BeanShellAssertion" testname="BeanShell Assertion" enabled="true">
                <stringProp name="BeanShellAssertion.query">${__setProperty(token, ${token})};</stringProp>
                <stringProp name="BeanShellAssertion.filename"></stringProp>
                <stringProp name="BeanShellAssertion.parameters"></stringProp>
                <boolProp name="BeanShellAssertion.resetInterpreter">false</boolProp>
              </BeanShellAssertion>
              <hashTree/>
            </hashTree>
            <JSR223Sampler guiclass="TestBeanGUI" testclass="JSR223Sampler" testname="Set PG Offline Tags Api Body" enabled="true">
              <stringProp name="cacheKey">false</stringProp>
              <stringProp name="filename"></stringProp>
              <stringProp name="parameters"></stringProp>
              <stringProp name="script">import groovy.json.*
import java.util.GregorianCalendar;
import java.util.Calendar;
import java.util.Date;
import java.util.Random;

// 17280 - 10 mins - are there in 4 months

Calendar setInitialCal; //definitions and declarations not happening in if stmt for groovy maybe
//setIntialCal = Calendar.getInstance();
Calendar curBatchSetCal;

setInitialCal = Calendar.getInstance();
	curBatchSetCal = Calendar.getInstance();


Long initialTimeMillis;
Long curBatchInitialTimeMillis;

Long globalInitialTimeMillis;

if(${tenMinsBatchCounter}==0){
	
	setInitialCal = Calendar.getInstance();
	curBatchSetCal = Calendar.getInstance();
		
log.info(&quot;++++++++22++++++++&quot;);
	initialTimeMillis = setInitialCal.getTimeInMillis();
	log.info(&quot;++++++24++++++++++&quot;);
	globalInitialTimeMillis = setInitialCal.getTimeInMillis();
	vars.put(&quot;initialTimeMillisVar&quot;, String.valueOf(initialTimeMillis));
//log.info(&quot;INITIAL TIME MILLIS VAR:&quot;+String.valueOf(vars.get(&quot;initialTimeMillisVar&quot;)));
	curBatchSetCal.setTimeInMillis(Long.valueOf(vars.get(&quot;initialTimeMillisVar&quot;)));
	log.info(&quot;+++++++30+++++++++&quot;);
	curBatchInitialTimeMillis = curBatchSetCal.getTimeInMillis();
	
	vars.put(&quot;curBatchInitialTimeMillisVar&quot;, String.valueOf(curBatchInitialTimeMillis));
	vars.put(&quot;globalInitialTimeMillisVar&quot;, String.valueOf(globalInitialTimeMillis));
	
}



// use else
else{
	log.info(&quot;HAHAHAHA&quot;);
log.info(String.valueOf(${tenMinsBatchCounter}));
curBatchSetCal.setTimeInMillis(Long.valueOf(vars.get(&quot;globalInitialTimeMillisVar&quot;)));
}

// needed to change the below as one hour resolution is going to set some data in reasonable time

//curBatchSetCal.add(Calendar.MINUTE, (-10)*(Integer.valueOf(${tenMinsBatchCounter})));

curBatchSetCal.add(Calendar.HOUR, (-1)*(Integer.valueOf(${tenMinsBatchCounter})));


log.info(&quot;--------------- 10 MINS BATCH COUNTER -----------------&quot;);
log.info(String.valueOf(${tenMinsBatchCounter}));
log.info(&quot;--------------- 10 MINS BATCH COUNTER -----------------&quot;);

randomValue = new Random();

BigInteger timeStamp = 0;
BigInteger startTimeStamp = 0;
BigInteger curStartTimeMillisLocVar = 0;
BigInteger curEndTimeMillisLocVar = 0;


BigInteger[] timeTickArray = new BigInteger[31];
//log.info(&quot;++++++56++++++++++&quot;);
timeTickArray[0] = (curBatchSetCal.getTimeInMillis() * 10000) + 621355968000000000 - 26586006500000;

//600 seconds calc //needed to change the below loop as it was time consuming a lot

//for (int i = 1;i&lt;31;++i)
//{
//	curBatchSetCal.add(Calendar.SECOND, 20);
////	log.info(&quot;+++++++63+++++++++&quot;);
//	timeTickArray[i] = (curBatchSetCal.getTimeInMillis() * 10000) + 621355968000000000 - 26586006500000;
//}

for (int i = 1;i&lt;2;++i)
{
//	curBatchSetCal.add(Calendar.HOUR, 1); //as already taken care of in THIS CASE
//	log.info(&quot;+++++++63+++++++++&quot;);
	timeTickArray[i] = (curBatchSetCal.getTimeInMillis() * 10000) + 621355968000000000 - 26586006500000;
}

def String strOfflineBody = &quot;&quot;;

def String reqParametersStr = &apos;{&quot;collectionType&quot;: &quot;Offline&quot;,&quot;dataStream&quot;:&quot;Live&quot;,&quot;triggerType&quot;: &quot;Trend&quot;,&quot;sampleSets&quot;:[&apos;;

def String combSamplesStr = &quot;&quot;;

def String closingBracketStr = &quot;]}&quot;;


//def Integer curGroupNum = ctx.getThreadGroup().getNumberOfThreads();
//def String curGroupStr = String.valueOf(curGroupNum);


for(int j = 1;j&lt;=300;++j){

def ranInt = randomValue.nextInt(90);

//samplesSetStr=&apos;{ &quot;tagId&quot;: &quot;RelTestPERF_AWS_5APR23_OfflineTag_&apos;+j+&apos;_G_&apos;+String.valueOf(${groupNumCounter})+&apos;&quot;, &quot;Samples&quot;: [{\&quot;value\&quot;:60.0,\&quot;dataStatus\&quot;:0,\&quot;nodeStatus\&quot;:0,\&quot;timeStamp\&quot;:&apos;+timeTickArray[0]+&apos;},{\&quot;value\&quot;:&apos;+String.valueOf(randomValue.nextInt(90))+&apos;,\&quot;dataStatus\&quot;:0,\&quot;nodeStatus\&quot;:0,\&quot;timeStamp\&quot;:&apos;+timeTickArray[1]+&apos;},{\&quot;value\&quot;:&apos;+String.valueOf(randomValue.nextInt(90))+&apos;,\&quot;dataStatus\&quot;:0,\&quot;nodeStatus\&quot;:0,\&quot;timeStamp\&quot;:&apos;+timeTickArray[2]+&apos;},{\&quot;value\&quot;:&apos;+String.valueOf(randomValue.nextInt(90))+&apos;,\&quot;dataStatus\&quot;:0,\&quot;nodeStatus\&quot;:0,\&quot;timeStamp\&quot;:&apos;+timeTickArray[3]+&apos;},{\&quot;value\&quot;:&apos;+String.valueOf(randomValue.nextInt(90))+&apos;,\&quot;dataStatus\&quot;:0,\&quot;nodeStatus\&quot;:0,\&quot;timeStamp\&quot;:&apos;+timeTickArray[4]+&apos;},{\&quot;value\&quot;:&apos;+String.valueOf(randomValue.nextInt(90))+&apos;,\&quot;dataStatus\&quot;:0,\&quot;nodeStatus\&quot;:0,\&quot;timeStamp\&quot;:&apos;+timeTickArray[5]+&apos;},{\&quot;value\&quot;:&apos;+String.valueOf(randomValue.nextInt(90))+&apos;,\&quot;dataStatus\&quot;:0,\&quot;nodeStatus\&quot;:0,\&quot;timeStamp\&quot;:&apos;+timeTickArray[6]+&apos;},{\&quot;value\&quot;:&apos;+String.valueOf(randomValue.nextInt(90))+&apos;,\&quot;dataStatus\&quot;:0,\&quot;nodeStatus\&quot;:0,\&quot;timeStamp\&quot;:&apos;+timeTickArray[7]+&apos;},{\&quot;value\&quot;:&apos;+String.valueOf(randomValue.nextInt(90))+&apos;,\&quot;dataStatus\&quot;:0,\&quot;nodeStatus\&quot;:0,\&quot;timeStamp\&quot;:&apos;+timeTickArray[8]+&apos;},{\&quot;value\&quot;:&apos;+String.valueOf(randomValue.nextInt(90))+&apos;,\&quot;dataStatus\&quot;:0,\&quot;nodeStatus\&quot;:0,\&quot;timeStamp\&quot;:&apos;+timeTickArray[9]+&apos;},{\&quot;value\&quot;:&apos;+String.valueOf(randomValue.nextInt(90))+&apos;,\&quot;dataStatus\&quot;:0,\&quot;nodeStatus\&quot;:0,\&quot;timeStamp\&quot;:&apos;+timeTickArray[10]+&apos;},{\&quot;value\&quot;:&apos;+String.valueOf(randomValue.nextInt(90))+&apos;,\&quot;dataStatus\&quot;:0,\&quot;nodeStatus\&quot;:0,\&quot;timeStamp\&quot;:&apos;+timeTickArray[11]+&apos;},{\&quot;value\&quot;:&apos;+String.valueOf(randomValue.nextInt(90))+&apos;,\&quot;dataStatus\&quot;:0,\&quot;nodeStatus\&quot;:0,\&quot;timeStamp\&quot;:&apos;+timeTickArray[12]+&apos;},{\&quot;value\&quot;:&apos;+String.valueOf(randomValue.nextInt(90))+&apos;,\&quot;dataStatus\&quot;:0,\&quot;nodeStatus\&quot;:0,\&quot;timeStamp\&quot;:&apos;+timeTickArray[13]+&apos;},{\&quot;value\&quot;:&apos;+String.valueOf(randomValue.nextInt(90))+&apos;,\&quot;dataStatus\&quot;:0,\&quot;nodeStatus\&quot;:0,\&quot;timeStamp\&quot;:&apos;+timeTickArray[14]+&apos;},{\&quot;value\&quot;:&apos;+String.valueOf(randomValue.nextInt(90))+&apos;,\&quot;dataStatus\&quot;:0,\&quot;nodeStatus\&quot;:0,\&quot;timeStamp\&quot;:&apos;+timeTickArray[15]+&apos;},{\&quot;value\&quot;:&apos;+String.valueOf(randomValue.nextInt(90))+&apos;,\&quot;dataStatus\&quot;:0,\&quot;nodeStatus\&quot;:0,\&quot;timeStamp\&quot;:&apos;+timeTickArray[16]+&apos;},{\&quot;value\&quot;:&apos;+String.valueOf(randomValue.nextInt(90))+&apos;,\&quot;dataStatus\&quot;:0,\&quot;nodeStatus\&quot;:0,\&quot;timeStamp\&quot;:&apos;+timeTickArray[17]+&apos;},{\&quot;value\&quot;:&apos;+String.valueOf(randomValue.nextInt(90))+&apos;,\&quot;dataStatus\&quot;:0,\&quot;nodeStatus\&quot;:0,\&quot;timeStamp\&quot;:&apos;+timeTickArray[18]+&apos;},{\&quot;value\&quot;:&apos;+String.valueOf(randomValue.nextInt(90))+&apos;,\&quot;dataStatus\&quot;:0,\&quot;nodeStatus\&quot;:0,\&quot;timeStamp\&quot;:&apos;+timeTickArray[19]+&apos;},{\&quot;value\&quot;:&apos;+String.valueOf(randomValue.nextInt(90))+&apos;,\&quot;dataStatus\&quot;:0,\&quot;nodeStatus\&quot;:0,\&quot;timeStamp\&quot;:&apos;+timeTickArray[20]+&apos;},{\&quot;value\&quot;:&apos;+String.valueOf(randomValue.nextInt(90))+&apos;,\&quot;dataStatus\&quot;:0,\&quot;nodeStatus\&quot;:0,\&quot;timeStamp\&quot;:&apos;+timeTickArray[21]+&apos;},{\&quot;value\&quot;:&apos;+String.valueOf(randomValue.nextInt(90))+&apos;,\&quot;dataStatus\&quot;:0,\&quot;nodeStatus\&quot;:0,\&quot;timeStamp\&quot;:&apos;+timeTickArray[22]+&apos;},{\&quot;value\&quot;:&apos;+String.valueOf(randomValue.nextInt(90))+&apos;,\&quot;dataStatus\&quot;:0,\&quot;nodeStatus\&quot;:0,\&quot;timeStamp\&quot;:&apos;+timeTickArray[23]+&apos;},{\&quot;value\&quot;:&apos;+String.valueOf(randomValue.nextInt(90))+&apos;,\&quot;dataStatus\&quot;:0,\&quot;nodeStatus\&quot;:0,\&quot;timeStamp\&quot;:&apos;+timeTickArray[24]+&apos;},{\&quot;value\&quot;:&apos;+String.valueOf(randomValue.nextInt(90))+&apos;,\&quot;dataStatus\&quot;:0,\&quot;nodeStatus\&quot;:0,\&quot;timeStamp\&quot;:&apos;+timeTickArray[25]+&apos;},{\&quot;value\&quot;:&apos;+String.valueOf(randomValue.nextInt(90))+&apos;,\&quot;dataStatus\&quot;:0,\&quot;nodeStatus\&quot;:0,\&quot;timeStamp\&quot;:&apos;+timeTickArray[26]+&apos;},{\&quot;value\&quot;:&apos;+String.valueOf(randomValue.nextInt(90))+&apos;,\&quot;dataStatus\&quot;:0,\&quot;nodeStatus\&quot;:0,\&quot;timeStamp\&quot;:&apos;+timeTickArray[27]+&apos;},{\&quot;value\&quot;:&apos;+String.valueOf(randomValue.nextInt(90))+&apos;,\&quot;dataStatus\&quot;:0,\&quot;nodeStatus\&quot;:0,\&quot;timeStamp\&quot;:&apos;+timeTickArray[28]+&apos;},{\&quot;value\&quot;:&apos;+String.valueOf(randomValue.nextInt(90))+&apos;,\&quot;dataStatus\&quot;:0,\&quot;nodeStatus\&quot;:0,\&quot;timeStamp\&quot;:&apos;+timeTickArray[29]+&apos;}], &quot;sampleType&quot;: &quot;StaticDataSample&quot;},&apos;;

samplesSetStr=&apos;{ &quot;tagId&quot;: &quot;RelTestPERF_AWS_5APR23_OfflineTag_&apos;+j+&apos;_G_&apos;+String.valueOf(${groupNumCounter})+&apos;&quot;, &quot;Samples&quot;: [{\&quot;value\&quot;:&apos;+String.valueOf(randomValue.nextInt(90))+&apos;,\&quot;dataStatus\&quot;:0,\&quot;nodeStatus\&quot;:0,\&quot;timeStamp\&quot;:&apos;+timeTickArray[0]+&apos;}], &quot;sampleType&quot;: &quot;StaticDataSample&quot;},&apos;;

combSamplesStr = combSamplesStr+samplesSetStr;

}

strOfflineBody = reqParametersStr+combSamplesStr+closingBracketStr;

vars.put(&quot;Payload_SetPGOfflineTags&quot;, strOfflineBody);
</stringProp>
              <stringProp name="scriptLanguage">groovy</stringProp>
            </JSR223Sampler>
            <hashTree/>
            <HTTPSamplerProxy guiclass="HttpTestSampleGui" testclass="HTTPSamplerProxy" testname="SetDataPgTagRequest" enabled="true">
              <boolProp name="HTTPSampler.postBodyRaw">true</boolProp>
              <elementProp name="HTTPsampler.Arguments" elementType="Arguments">
                <collectionProp name="Arguments.arguments">
                  <elementProp name="" elementType="HTTPArgument">
                    <boolProp name="HTTPArgument.always_encode">false</boolProp>
                    <stringProp name="Argument.value">${Payload_SetPGOfflineTags}</stringProp>
                    <stringProp name="Argument.metadata">=</stringProp>
                  </elementProp>
                </collectionProp>
              </elementProp>
              <stringProp name="HTTPSampler.domain">perf.np-0000197.npause1.bakerhughes.com</stringProp>
              <stringProp name="HTTPSampler.port"></stringProp>
              <stringProp name="HTTPSampler.protocol">https</stringProp>
              <stringProp name="HTTPSampler.contentEncoding"></stringProp>
              <stringProp name="HTTPSampler.path">timeseries/v1/data/static</stringProp>
              <stringProp name="HTTPSampler.method">POST</stringProp>
              <boolProp name="HTTPSampler.follow_redirects">true</boolProp>
              <boolProp name="HTTPSampler.auto_redirects">false</boolProp>
              <boolProp name="HTTPSampler.use_keepalive">true</boolProp>
              <boolProp name="HTTPSampler.DO_MULTIPART_POST">false</boolProp>
              <stringProp name="HTTPSampler.embedded_url_re"></stringProp>
              <stringProp name="HTTPSampler.connect_timeout"></stringProp>
              <stringProp name="HTTPSampler.response_timeout"></stringProp>
            </HTTPSamplerProxy>
            <hashTree>
              <HeaderManager guiclass="HeaderPanel" testclass="HeaderManager" testname="HTTP Header Manager" enabled="true">
                <collectionProp name="HeaderManager.headers">
                  <elementProp name="" elementType="Header">
                    <stringProp name="Header.name">tenantID</stringProp>
                    <stringProp name="Header.value">${tenant}</stringProp>
                  </elementProp>
                  <elementProp name="" elementType="Header">
                    <stringProp name="Header.name">Content-Type</stringProp>
                    <stringProp name="Header.value">application/json</stringProp>
                  </elementProp>
                  <elementProp name="" elementType="Header">
                    <stringProp name="Header.name">Authorization</stringProp>
                    <stringProp name="Header.value">Bearer ${__property(token)}</stringProp>
                  </elementProp>
                </collectionProp>
              </HeaderManager>
              <hashTree/>
              <ResponseAssertion guiclass="AssertionGui" testclass="ResponseAssertion" testname="Response Assertion" enabled="true">
                <collectionProp name="Asserion.test_strings">
                  <stringProp name="1598">20</stringProp>
                </collectionProp>
                <stringProp name="Assertion.custom_message"></stringProp>
                <stringProp name="Assertion.test_field">Assertion.response_code</stringProp>
                <boolProp name="Assertion.assume_success">false</boolProp>
                <intProp name="Assertion.test_type">16</intProp>
              </ResponseAssertion>
              <hashTree/>
            </hashTree>
          </hashTree>
        </hashTree>
        <HTTPSamplerProxy guiclass="HttpTestSampleGui" testclass="HTTPSamplerProxy" testname="CreateNewTagRequest" enabled="false">
          <boolProp name="HTTPSampler.postBodyRaw">true</boolProp>
          <elementProp name="HTTPsampler.Arguments" elementType="Arguments">
            <collectionProp name="Arguments.arguments">
              <elementProp name="" elementType="HTTPArgument">
                <boolProp name="HTTPArgument.always_encode">false</boolProp>
                <stringProp name="Argument.value">${Payload_CreatePgTag}</stringProp>
                <stringProp name="Argument.metadata">=</stringProp>
              </elementProp>
            </collectionProp>
          </elementProp>
          <stringProp name="HTTPSampler.domain">perf.np-0000197.npause1.bakerhughes.com</stringProp>
          <stringProp name="HTTPSampler.port"></stringProp>
          <stringProp name="HTTPSampler.protocol">https</stringProp>
          <stringProp name="HTTPSampler.contentEncoding"></stringProp>
          <stringProp name="HTTPSampler.path">timeseries/v1/tags</stringProp>
          <stringProp name="HTTPSampler.method">POST</stringProp>
          <boolProp name="HTTPSampler.follow_redirects">true</boolProp>
          <boolProp name="HTTPSampler.auto_redirects">false</boolProp>
          <boolProp name="HTTPSampler.use_keepalive">true</boolProp>
          <boolProp name="HTTPSampler.DO_MULTIPART_POST">false</boolProp>
          <stringProp name="HTTPSampler.embedded_url_re"></stringProp>
          <stringProp name="HTTPSampler.connect_timeout"></stringProp>
          <stringProp name="HTTPSampler.response_timeout"></stringProp>
        </HTTPSamplerProxy>
        <hashTree>
          <JSR223PreProcessor guiclass="TestBeanGUI" testclass="JSR223PreProcessor" testname="Payload Generator" enabled="false">
            <stringProp name="scriptLanguage">groovy</stringProp>
            <stringProp name="parameters"></stringProp>
            <stringProp name="filename"></stringProp>
            <stringProp name="cacheKey">true</stringProp>
            <stringProp name="script">import groovy.json.*

import java.util.GregorianCalendar;
import java.util.Calendar;
import java.util.Date;

//BigInteger timeStamp = 0;
//
//BigInteger startTimeStamp = 0;
//BigInteger incTicks = 600000000;

//Calendar c = Calendar.getInstance();


// USE VARIABLES FOR CONCURRENT USERS IN CODE KEEP IT AS A VARIABLE AND KEEP INCREASING IT BY 100 EVERY 1 SECOND OR SOMETHING LIKE THAT
// use ultimate thread group bzm thats it

//c.set(2021,01,01)
//
//c.set(Calendar.HOUR, 00);
//
//c.set(Calendar.MINUTE, 00);
//
//c.set(Calendar.SECOND, 00);
//log.info(String.valueOf(c));
//log.info(&quot;00000000000&quot;);


// 26586006500000
// 621355968010000000
// 621355968000000000
// 621355968000000000
// 637450559995600000
//c.add(Calendar.MINUTE, 1)
//timeStamp = (c.getTimeInMillis() * 10000) + 621355968000000000 - 26586006500000
//timeStamp = (c.getTimeInMillis() * 10000) + 621355968010000000 - 26586006500000
//timeStamp = (c.getTimeInMillis() * 10000) + 621355968000000000 - 26586006500000
//timeStamp = (c.getTimeInMillis() * 10000)
//timeStamp = (c.getTimeInMillis() * 10000) + 621355968000000000 - 26586006500000
//timeStamp = (c.getTimeInMillis() * 10000) + 662132938200000000
//timeStamp = (c.getTimeInMillis() * 10000) + 621355824000000000

//timeStamp = (c.getTimeInMillis() * 10000);

//log.info(String.valueOf(startTimeStamp))

//c.add(Calendar.MINUTE, 1)
//timeStamp = (c.getTimeInMillis() * 10000) + 621355968010000000 - 26586006500000
//log.info(&quot;WWWWWWWWWW&quot;);
//log.info(String.valueOf(timeStamp));
//
//c.add(Calendar.MINUTE, 1)
//timeStamp = (c.getTimeInMillis() * 10000) + 621355968010000000 - 26586006500000
//log.info(&quot;WWWWWWWWWW&quot;);
//log.info(String.valueOf(timeStamp));
//
//c.add(Calendar.MINUTE, 1)
//timeStamp = (c.getTimeInMillis() * 10000) + 621355968010000000 - 26586006500000
//log.info(&quot;WWWWWWWWWW&quot;);
//log.info(String.valueOf(timeStamp));
//
//c.add(Calendar.MINUTE, 1)
//timeStamp = (c.getTimeInMillis() * 10000) + 621355968010000000 - 26586006500000
//log.info(&quot;WWWWWWWWWW&quot;);
//log.info(String.valueOf(timeStamp));
//

//c.add(Calendar.MINUTE, 1)
//timeStamp = startTimeStamp + 621328950000000000
//log.info(&quot;WWWWWWWWWW&quot;);
//log.info(String.valueOf(timeStamp));

//startTimeStamp = 637450560600000000;

//timeStamp = startTimeStamp + incTicks;

//timeStamp = startTimeStamp;

//1 week = 10080 minutes
//1 month = 43800 minutes
//1 year = 525960 minutes

// 31700000 seconds in an year

//for (long i=1;i&lt;=60;++i){
//	log.info(&quot;*****I I I i i i ******&quot;);
//	log.info(String.valueOf(i));
//	timeStamp = startTimeStamp + 621328950000000000 + (i*590429952)

//timeStamp = (c.getTimeInMillis() * 10000) + 621355968000000000

// startTimeStamp = 637450560600000000
// incTicks = 600000000

//if(i==1){
//	timeStamp = startTimeStamp;
//}
//else{
//timeStamp = timeStamp + incTicks;
//}

//timeStamp = startTimeStamp + (i*600000000);

//log.info(String.valueOf(i));
//log.info(String.valueOf(timeStamp));


//c.add(Calendar.MINUTE, 1)



//
//c.add(Calendar.MINUTE, 1)
//timeStamp = timeStamp + 
//log.info(&quot;WWWWWWWWWW&quot;);
//log.info(String.valueOf(timeStamp));

//c.add(Calendar.MINUTE, 1)
//timeStamp = startTimeStamp + 621328950000000000 + 590429952
//log.info(&quot;WWWWWWWWWW&quot;);
//log.info(String.valueOf(timeStamp));
//
//c.add(Calendar.MINUTE, 1)
//timeStamp = startTimeStamp + 621328950000000000 +590429952 + 590429952
//timeStamp = startTimeStamp + 621328950000000000 + 2*(590429952)
////timeStamp = timeStamp+ 590429952
//log.info(&quot;WWWWWWWWWW&quot;);
//log.info(String.valueOf(timeStamp));

//c.add(Calendar.MINUTE, 1)
//timeStamp = startTimeStamp + 621328950000000000 +  590429952 + 590429952 + 590429952
//timeStamp = startTimeStamp + 621328950000000000 +  3*(590429952)
//log.info(&quot;WWWWWWWWWW&quot;);
//log.info(String.valueOf(timeStamp));

//c.add(Calendar.MINUTE, 1)
//timeStamp = startTimeStamp + 621328950000000000 + 590429952 + 590429952 + 590429952 + 590429952
//log.info(&quot;WWWWWWWWWW&quot;);
//log.info(String.valueOf(timeStamp));
//
////c.add(Calendar.MINUTE, 1)
//timeStamp = startTimeStamp + 621328950000000000 + 590429952 + 590429952 + 590429952 + 590429952 + 590429952
//log.info(&quot;WWWWWWWWWW&quot;);
//log.info(String.valueOf(timeStamp));

//String testPlanFile = GuiPackage.getInstance().getTestPlanFile();
//String testPlanFileDir = FilenameUtils.getFullPathNoEndSeparator(testPlanFile);

/*
 String groupName = ctx.getThreadGroup().getName();
log.info(groupName);
 */

/* 
  ${__threadGroupName} works fine to fetch Thread group
 */

 /*
  By default you can get the current sampler&apos;s name and current thread group&apos;s name using the following in-built JMeter functions

Current thread group name -&gt; ${__threadGroupName}

Current sampler name -&gt; ${__samplerName()}

Within the sampler name function you can store it into a variable and reuse it in subsequent places

${__samplerName(previousSamplerName)}
  */

//def path = FileServer.getFileServer().getBaseDir();
//def separator = File.separator;

//String fileName = &quot;tags.csv&quot;;
//String fileName = &quot;Offline_Tags_1.csv&quot;;
//def fileContents = new File(path+separator+fileName);
//def lines = fileContents.readLines()

//
//println &quot;************* size ********************* &quot;+lines.size()

//if(lines.size() &gt;= NumberOfTagsPerRequest)
//
////for(int TagCounter = 0;TagCounter&lt;NumberOfTagsPerRequest;TagCounter++) {
//for(int TagCounter = 1;TagCounter&lt;=NumberOfTagsPerRequest;TagCounter++) {
//println &quot;************* size ********************* &quot;+lines.get(TagCounter)
//
//	def SS = new SampleSet()		
//	
//	SS.tagId =lines.get(TagCounter)
//	SS.sampleType =&quot;StaticDataSample&quot;
//	SS.samples = new ArrayList&lt;SampleData&gt;()
//
//		
//	for(int SampleCounter = 0;SampleCounter&lt;NumberOfSamplesPerRequest;SampleCounter++) {
//		
//		def SD = new SampleData()
//		c.add(Calendar.MINUTE, 1)
//		SD.timeStamp = (c.getTimeInMillis() * 10000) + 621355968000000000
//		SD.dataStatus =0
//		SD.nodeStatus =0
//		SD.value=org.apache.commons.lang3.RandomUtils.nextInt(1, 1000)
//		
//		SS.samples &lt;&lt; SD
//	
//	}
//	data.SampleSets &lt;&lt; SS
//	
//}

//fileContents.eachLine { line -&gt;
//
//	def SS = new SampleSet()		
//	
//	SS.tagId =line
//	SS.sampleType =&quot;StaticDataSample&quot;
//	SS.samples = new ArrayList&lt;SampleData&gt;()
//
//		
//	for(int SampleCounter = 0;SampleCounter&lt;NumberOfSamplesPerRequest;SampleCounter++) {
//		
//		def SD = new SampleData()
//		c.add(Calendar.MINUTE, 1)
//		SD.timeStamp = (c.getTimeInMillis() * 10000) + 621355968000000000
//		SD.dataStatus =0
//		SD.nodeStatus =0
//		SD.value=org.apache.commons.lang3.RandomUtils.nextInt(1, 1000)
//		
//		SS.samples &lt;&lt; SD
//	
//	}
//	data.SampleSets &lt;&lt; SS
//	
//}


//def PayloadJson = JsonOutput.toJson(data)

//def str = &apos;{
//    &quot;collectionType&quot;: &quot;Offline&quot;,
//    &quot;dataStream&quot;: &quot;Live&quot;,
//    &quot;triggerType&quot;: &quot;Trend&quot;,
//    &quot;sampleSets&quot;: [
//        {
//            &quot;tagId&quot;: &quot;Offline_Tag_456-new-groupid-perfaz&quot;,
//            &quot;samples&quot;: [
//                {
//                    &quot;timeStamp&quot;: 637771539000000000,
//                    &quot;dataStatus&quot;: 0,
//                    &quot;nodeStatus&quot;: 0,
//                    &quot;value&quot;: 12.05
//                }
//            ],
//            &quot;sampleType&quot;: &quot;StaticDataSample&quot;
//        }
//    ]
//}&apos;
//def str = &apos;{&quot;ABC&quot;:{&quot;total&quot;:0,&quot;failed&quot;:0,&quot;skipped&quot;:0}}], [{&quot;BCD&quot;: {&quot;total&quot;:0,&quot;failed&quot;:0,&quot;skipped&quot;:0}}&apos;																	


//for(int i=0;i&lt;100;++i)
//{

//	def tagIdStr = args[0]
//	log.info(&quot;************* TAGID ********************* &quot;+tagIdStr)					
//	def str =&apos;{&quot;collectionType&quot;: &quot;Offline&quot;,&quot;dataStream&quot;: &quot;Live&quot;,&quot;triggerType&quot;: &quot;Trend&quot;,&quot;sampleSets&quot;: [{&quot;tagId&quot;: &quot;Offline_tag_1500&quot;,&quot;samples&quot;: [{&quot;timeStamp&quot;: 637771539000000000,&quot;dataStatus&quot;: 0,&quot;nodeStatus&quot;: 0,&quot;value&quot;: 12.05 }],&quot;sampleType&quot;: &quot;StaticDataSample&quot; }]}&apos;

//j means number of tags

for(long j = 1;j&lt;=5;++j){
	log.info(&quot;***J J J value j j j***\n&quot;);
	log.info(String.valueOf(j));
	def str = &quot;&quot;

//	str = &apos;{&quot;collectionType&quot;: &quot;Online&quot;,&quot;dataStream&quot;: &quot;Live&quot;,&quot;triggerType&quot;: &quot;Trend&quot;,&quot;sampleSets&quot;: [{&quot;tagId&quot;: &quot;&apos; + tagIdStr + &apos;&quot;,&quot;samples&quot;: [{&quot;timeStamp&quot;: 637771539000000000,&quot;dataStatus&quot;: 0,&quot;nodeStatus&quot;: 0,&quot;value&quot;: 12.05 }],&quot;sampleType&quot;: &quot;StaticDataSample&quot; }]}&apos;
//

//str = &apos;{&quot;tagIds&quot;: [&quot;&apos;+tagIdStr+&apos;&quot;],&quot;startTime&quot;: 637451064600000000,&quot;endTime&quot;: 637908299170000000,&quot;summaryTypes&quot;: [&quot;MinValue&quot;,&quot;MaxValue&quot;],&quot;triggerTypeProportions&quot;: {&quot;Trend&quot;: &quot;60&quot;,&quot;Alarm&quot;: &quot;30&quot;,&quot;Transient&quot;: &quot;10&quot;},&quot;maxNumberOfSamplesPerTag&quot;: 50, &quot;requestedStatusBits&quot;: 0, &quot;associatedTagIds&quot;: { }}&apos;

//	str = &apos;{    &quot;collectionType&quot;: &quot;Online&quot;,&quot;dataStream&quot;:&quot;Live&quot;,&quot;triggerType&quot;: &quot;Trend&quot;,&quot;sampleSets&quot;:[{ &quot;tagId&quot;: &quot;Online_Tag_&quot;,&apos;+j+&apos;            &quot;samples&quot;: [ {                    &quot;value&quot;: 0,                    &quot;nodeStatus&quot;: 0,                    &quot;timeStamp&quot;: 637450560000000000,                    &quot;dataStatus&quot;: 0                },                {                    &quot;value&quot;: 1,                    &quot;nodeStatus&quot;: 0,                    &quot;timeStamp&quot;: 637450560600000000,                    &quot;dataStatus&quot;: 0                },                {                    &quot;value&quot;: 2,                    &quot;nodeStatus&quot;: 0,                    &quot;timeStamp&quot;: 637450561200000000,                    &quot;dataStatus&quot;: 0                }      ],            &quot;sampleType&quot;: &quot;StaticDataSample&quot;        }    ]}&apos;

//str = &apos;{    &quot;collectionType&quot;: &quot;Offline&quot;,&quot;dataStream&quot;:&quot;Live&quot;,&quot;triggerType&quot;: &quot;Trend&quot;,&quot;sampleSets&quot;:[{ &quot;tagId&quot;: &quot;Offline_Tag_&apos;+j+&apos;&quot;, &quot;samples&quot;: [{&quot;value&quot;: 123,&quot;nodeStatus&quot;: 0, &quot;timeStamp&quot;: &apos;+ timeStamp +&apos;,&quot;dataStatus&quot;: 0}],&quot;sampleType&quot;: &quot;StaticDataSample&quot;}]}&apos;


str=&quot;[{\&quot;Id\&quot;:\&quot;July15_PI_Float64_224\&quot;,\&quot;Name\&quot;:\&quot;July15_PI_Float64_224\&quot;,\&quot;Description\&quot;:\&quot;AmbientPressure\&quot;,\&quot;GroupId\&quot;:\&quot;S1E2C-PROTO4\&quot;,\&quot;CollectionType\&quot;:\&quot;Offline\&quot;,\&quot;DataType\&quot;:\&quot;Float64\&quot;,\&quot;StorageClass\&quot;:[\&quot;Raw\&quot;,\&quot;Tiered\&quot;],\&quot;Unit\&quot;:null,\&quot;SubUnit\&quot;:null,\&quot;DataSourceType\&quot;:\&quot;PI\&quot;}]&quot;
	
	//def parser = new JsonSlurper()
	//def json = parser.parseText(str)
	
	//vars.put(&quot;Payload&quot;, PayloadJson)
	//vars.put(&quot;Payload&quot;, json)
	//log.info(&quot;************* JSON SLURPER  ********************* &quot;+vars.get(&quot;Payload&quot;))
	
	vars.put(&quot;Payload&quot;, str)
	log.info(&quot;************* Set Data ********************* &quot;+vars.get(&quot;Payload&quot;))
	
}
//}
	
	//println &quot;************* create tag ********************* &quot;+vars.get(&quot;Payload&quot;)
//	log.info(&quot;************* Set Data ********************* &quot;+vars.get(&quot;Payload&quot;))
	
	//println &quot;************* create tag ********************* &quot;+vars.get(&quot;Payload&quot;)
	//log.info(&quot;************* Set Data ********************* &quot;+vars.get(&quot;Payload&quot;))
//}
</stringProp>
          </JSR223PreProcessor>
          <hashTree/>
          <JSR223PreProcessor guiclass="TestBeanGUI" testclass="JSR223PreProcessor" testname="Payload Generator" enabled="false">
            <stringProp name="scriptLanguage">groovy</stringProp>
            <stringProp name="parameters"></stringProp>
            <stringProp name="filename"></stringProp>
            <stringProp name="cacheKey">false</stringProp>
            <stringProp name="script">import groovy.json.*


// VERY VERY IMP: REMOVE/UNCHECK CACHE COMPILED SCRIPT ABOVE OPTION ELSE COUNTER WONT WORK


import java.util.GregorianCalendar;
import java.util.Calendar;
import java.util.Date;

import java.net.InetAddress;

import org.slf4j.Logger;
import org.slf4j.LoggerFactory;

ip = InetAddress.getLocalHost();

Logger logger = LoggerFactory.getLogger(&quot;IPLogger&quot;);


	        log.info(&quot;#########################################&quot;);
            log.info(&quot;IP of system is := &quot; + ip.getHostAddress());
            logger.info(&quot;IP of system is := &quot; + ip.getHostAddress());
           log.info(&quot;#########################################&quot;);

//BigInteger timeStamp = 0;
//
//BigInteger startTimeStamp = 0;
//BigInteger incTicks = 600000000;

//Calendar c = Calendar.getInstance();


// USE VARIABLES FOR CONCURRENT USERS IN CODE KEEP IT AS A VARIABLE AND KEEP INCREASING IT BY 100 EVERY 1 SECOND OR SOMETHING LIKE THAT
// use ultimate thread group bzm thats it

//c.set(2021,01,01)
//
//c.set(Calendar.HOUR, 00);
//
//c.set(Calendar.MINUTE, 00);
//
//c.set(Calendar.SECOND, 00);
//log.info(String.valueOf(c));
//log.info(&quot;00000000000&quot;);


// 26586006500000
// 621355968010000000
// 621355968000000000
// 621355968000000000
// 637450559995600000
//c.add(Calendar.MINUTE, 1)
//timeStamp = (c.getTimeInMillis() * 10000) + 621355968000000000 - 26586006500000
//timeStamp = (c.getTimeInMillis() * 10000) + 621355968010000000 - 26586006500000
//timeStamp = (c.getTimeInMillis() * 10000) + 621355968000000000 - 26586006500000
//timeStamp = (c.getTimeInMillis() * 10000)
//timeStamp = (c.getTimeInMillis() * 10000) + 621355968000000000 - 26586006500000
//timeStamp = (c.getTimeInMillis() * 10000) + 662132938200000000
//timeStamp = (c.getTimeInMillis() * 10000) + 621355824000000000

//timeStamp = (c.getTimeInMillis() * 10000);

//log.info(String.valueOf(startTimeStamp))

//c.add(Calendar.MINUTE, 1)
//timeStamp = (c.getTimeInMillis() * 10000) + 621355968010000000 - 26586006500000
//log.info(&quot;WWWWWWWWWW&quot;);
//log.info(String.valueOf(timeStamp));
//
//c.add(Calendar.MINUTE, 1)
//timeStamp = (c.getTimeInMillis() * 10000) + 621355968010000000 - 26586006500000
//log.info(&quot;WWWWWWWWWW&quot;);
//log.info(String.valueOf(timeStamp));
//
//c.add(Calendar.MINUTE, 1)
//timeStamp = (c.getTimeInMillis() * 10000) + 621355968010000000 - 26586006500000
//log.info(&quot;WWWWWWWWWW&quot;);
//log.info(String.valueOf(timeStamp));
//
//c.add(Calendar.MINUTE, 1)
//timeStamp = (c.getTimeInMillis() * 10000) + 621355968010000000 - 26586006500000
//log.info(&quot;WWWWWWWWWW&quot;);
//log.info(String.valueOf(timeStamp));
//

//c.add(Calendar.MINUTE, 1)
//timeStamp = startTimeStamp + 621328950000000000
//log.info(&quot;WWWWWWWWWW&quot;);
//log.info(String.valueOf(timeStamp));

//startTimeStamp = 637450560600000000;

//timeStamp = startTimeStamp + incTicks;

//timeStamp = startTimeStamp;

//1 week = 10080 minutes
//1 month = 43800 minutes
//1 year = 525960 minutes

// 31700000 seconds in an year

//for (long i=1;i&lt;=60;++i){
//	log.info(&quot;*****I I I i i i ******&quot;);
//	log.info(String.valueOf(i));
//	timeStamp = startTimeStamp + 621328950000000000 + (i*590429952)

//timeStamp = (c.getTimeInMillis() * 10000) + 621355968000000000

// startTimeStamp = 637450560600000000
// incTicks = 600000000

//if(i==1){
//	timeStamp = startTimeStamp;
//}
//else{
//timeStamp = timeStamp + incTicks;
//}

//timeStamp = startTimeStamp + (i*600000000);

//log.info(String.valueOf(i));
//log.info(String.valueOf(timeStamp));


//c.add(Calendar.MINUTE, 1)



//
//c.add(Calendar.MINUTE, 1)
//timeStamp = timeStamp + 
//log.info(&quot;WWWWWWWWWW&quot;);
//log.info(String.valueOf(timeStamp));

//c.add(Calendar.MINUTE, 1)
//timeStamp = startTimeStamp + 621328950000000000 + 590429952
//log.info(&quot;WWWWWWWWWW&quot;);
//log.info(String.valueOf(timeStamp));
//
//c.add(Calendar.MINUTE, 1)
//timeStamp = startTimeStamp + 621328950000000000 +590429952 + 590429952
//timeStamp = startTimeStamp + 621328950000000000 + 2*(590429952)
////timeStamp = timeStamp+ 590429952
//log.info(&quot;WWWWWWWWWW&quot;);
//log.info(String.valueOf(timeStamp));

//c.add(Calendar.MINUTE, 1)
//timeStamp = startTimeStamp + 621328950000000000 +  590429952 + 590429952 + 590429952
//timeStamp = startTimeStamp + 621328950000000000 +  3*(590429952)
//log.info(&quot;WWWWWWWWWW&quot;);
//log.info(String.valueOf(timeStamp));

//c.add(Calendar.MINUTE, 1)
//timeStamp = startTimeStamp + 621328950000000000 + 590429952 + 590429952 + 590429952 + 590429952
//log.info(&quot;WWWWWWWWWW&quot;);
//log.info(String.valueOf(timeStamp));
//
////c.add(Calendar.MINUTE, 1)
//timeStamp = startTimeStamp + 621328950000000000 + 590429952 + 590429952 + 590429952 + 590429952 + 590429952
//log.info(&quot;WWWWWWWWWW&quot;);
//log.info(String.valueOf(timeStamp));

//String testPlanFile = GuiPackage.getInstance().getTestPlanFile();
//String testPlanFileDir = FilenameUtils.getFullPathNoEndSeparator(testPlanFile);

/*
 String groupName = ctx.getThreadGroup().getName();
log.info(groupName);
 */

/* 
  ${__threadGroupName} works fine to fetch Thread group
 */

 /*
  By default you can get the current sampler&apos;s name and current thread group&apos;s name using the following in-built JMeter functions

Current thread group name -&gt; ${__threadGroupName}

Current sampler name -&gt; ${__samplerName()}

Within the sampler name function you can store it into a variable and reuse it in subsequent places

${__samplerName(previousSamplerName)}
  */

//def path = FileServer.getFileServer().getBaseDir();
//def separator = File.separator;

//String fileName = &quot;tags.csv&quot;;
//String fileName = &quot;Offline_Tags_1.csv&quot;;
//def fileContents = new File(path+separator+fileName);
//def lines = fileContents.readLines()

//
//println &quot;************* size ********************* &quot;+lines.size()

//if(lines.size() &gt;= NumberOfTagsPerRequest)
//
////for(int TagCounter = 0;TagCounter&lt;NumberOfTagsPerRequest;TagCounter++) {
//for(int TagCounter = 1;TagCounter&lt;=NumberOfTagsPerRequest;TagCounter++) {
//println &quot;************* size ********************* &quot;+lines.get(TagCounter)
//
//	def SS = new SampleSet()		
//	
//	SS.tagId =lines.get(TagCounter)
//	SS.sampleType =&quot;StaticDataSample&quot;
//	SS.samples = new ArrayList&lt;SampleData&gt;()
//
//		
//	for(int SampleCounter = 0;SampleCounter&lt;NumberOfSamplesPerRequest;SampleCounter++) {
//		
//		def SD = new SampleData()
//		c.add(Calendar.MINUTE, 1)
//		SD.timeStamp = (c.getTimeInMillis() * 10000) + 621355968000000000
//		SD.dataStatus =0
//		SD.nodeStatus =0
//		SD.value=org.apache.commons.lang3.RandomUtils.nextInt(1, 1000)
//		
//		SS.samples &lt;&lt; SD
//	
//	}
//	data.SampleSets &lt;&lt; SS
//	
//}

//fileContents.eachLine { line -&gt;
//
//	def SS = new SampleSet()		
//	
//	SS.tagId =line
//	SS.sampleType =&quot;StaticDataSample&quot;
//	SS.samples = new ArrayList&lt;SampleData&gt;()
//
//		
//	for(int SampleCounter = 0;SampleCounter&lt;NumberOfSamplesPerRequest;SampleCounter++) {
//		
//		def SD = new SampleData()
//		c.add(Calendar.MINUTE, 1)
//		SD.timeStamp = (c.getTimeInMillis() * 10000) + 621355968000000000
//		SD.dataStatus =0
//		SD.nodeStatus =0
//		SD.value=org.apache.commons.lang3.RandomUtils.nextInt(1, 1000)
//		
//		SS.samples &lt;&lt; SD
//	
//	}
//	data.SampleSets &lt;&lt; SS
//	
//}


//def PayloadJson = JsonOutput.toJson(data)

//def str = &apos;{
//    &quot;collectionType&quot;: &quot;Offline&quot;,
//    &quot;dataStream&quot;: &quot;Live&quot;,
//    &quot;triggerType&quot;: &quot;Trend&quot;,
//    &quot;sampleSets&quot;: [
//        {
//            &quot;tagId&quot;: &quot;Offline_Tag_456-new-groupid-perfaz&quot;,
//            &quot;samples&quot;: [
//                {
//                    &quot;timeStamp&quot;: 637771539000000000,
//                    &quot;dataStatus&quot;: 0,
//                    &quot;nodeStatus&quot;: 0,
//                    &quot;value&quot;: 12.05
//                }
//            ],
//            &quot;sampleType&quot;: &quot;StaticDataSample&quot;
//        }
//    ]
//}&apos;
//def str = &apos;{&quot;ABC&quot;:{&quot;total&quot;:0,&quot;failed&quot;:0,&quot;skipped&quot;:0}}], [{&quot;BCD&quot;: {&quot;total&quot;:0,&quot;failed&quot;:0,&quot;skipped&quot;:0}}&apos;																	


//for(int i=0;i&lt;100;++i)
//{

//	def tagIdStr = args[0]
//	log.info(&quot;************* TAGID ********************* &quot;+tagIdStr)					
//	def str =&apos;{&quot;collectionType&quot;: &quot;Offline&quot;,&quot;dataStream&quot;: &quot;Live&quot;,&quot;triggerType&quot;: &quot;Trend&quot;,&quot;sampleSets&quot;: [{&quot;tagId&quot;: &quot;Offline_tag_1500&quot;,&quot;samples&quot;: [{&quot;timeStamp&quot;: 637771539000000000,&quot;dataStatus&quot;: 0,&quot;nodeStatus&quot;: 0,&quot;value&quot;: 12.05 }],&quot;sampleType&quot;: &quot;StaticDataSample&quot; }]}&apos;

//j means number of tags



//	str = &apos;{&quot;collectionType&quot;: &quot;Online&quot;,&quot;dataStream&quot;: &quot;Live&quot;,&quot;triggerType&quot;: &quot;Trend&quot;,&quot;sampleSets&quot;: [{&quot;tagId&quot;: &quot;&apos; + tagIdStr + &apos;&quot;,&quot;samples&quot;: [{&quot;timeStamp&quot;: 637771539000000000,&quot;dataStatus&quot;: 0,&quot;nodeStatus&quot;: 0,&quot;value&quot;: 12.05 }],&quot;sampleType&quot;: &quot;StaticDataSample&quot; }]}&apos;
//

//str = &apos;{&quot;tagIds&quot;: [&quot;&apos;+tagIdStr+&apos;&quot;],&quot;startTime&quot;: 637451064600000000,&quot;endTime&quot;: 637908299170000000,&quot;summaryTypes&quot;: [&quot;MinValue&quot;,&quot;MaxValue&quot;],&quot;triggerTypeProportions&quot;: {&quot;Trend&quot;: &quot;60&quot;,&quot;Alarm&quot;: &quot;30&quot;,&quot;Transient&quot;: &quot;10&quot;},&quot;maxNumberOfSamplesPerTag&quot;: 50, &quot;requestedStatusBits&quot;: 0, &quot;associatedTagIds&quot;: { }}&apos;

//	str = &apos;{    &quot;collectionType&quot;: &quot;Online&quot;,&quot;dataStream&quot;:&quot;Live&quot;,&quot;triggerType&quot;: &quot;Trend&quot;,&quot;sampleSets&quot;:[{ &quot;tagId&quot;: &quot;Online_Tag_&quot;,&apos;+j+&apos;            &quot;samples&quot;: [ {                    &quot;value&quot;: 0,                    &quot;nodeStatus&quot;: 0,                    &quot;timeStamp&quot;: 637450560000000000,                    &quot;dataStatus&quot;: 0                },                {                    &quot;value&quot;: 1,                    &quot;nodeStatus&quot;: 0,                    &quot;timeStamp&quot;: 637450560600000000,                    &quot;dataStatus&quot;: 0                },                {                    &quot;value&quot;: 2,                    &quot;nodeStatus&quot;: 0,                    &quot;timeStamp&quot;: 637450561200000000,                    &quot;dataStatus&quot;: 0                }      ],            &quot;sampleType&quot;: &quot;StaticDataSample&quot;        }    ]}&apos;

//str = &apos;{    &quot;collectionType&quot;: &quot;Offline&quot;,&quot;dataStream&quot;:&quot;Live&quot;,&quot;triggerType&quot;: &quot;Trend&quot;,&quot;sampleSets&quot;:[{ &quot;tagId&quot;: &quot;Offline_Tag_&apos;+j+&apos;&quot;, &quot;samples&quot;: [{&quot;value&quot;: 123,&quot;nodeStatus&quot;: 0, &quot;timeStamp&quot;: &apos;+ timeStamp +&apos;,&quot;dataStatus&quot;: 0}],&quot;sampleType&quot;: &quot;StaticDataSample&quot;}]}&apos;


//str=&quot;[{\&quot;Id\&quot;:\&quot;July15_PI_Float64_224\&quot;,\&quot;Name\&quot;:\&quot;July15_PI_Float64_224\&quot;,\&quot;Description\&quot;:\&quot;AmbientPressure\&quot;,\&quot;GroupId\&quot;:\&quot;S1E2C-PROTO4\&quot;,\&quot;CollectionType\&quot;:\&quot;Offline\&quot;,\&quot;DataType\&quot;:\&quot;Float64\&quot;,\&quot;StorageClass\&quot;:[\&quot;Raw\&quot;,\&quot;Tiered\&quot;],\&quot;Unit\&quot;:null,\&quot;SubUnit\&quot;:null,\&quot;DataSourceType\&quot;:\&quot;PI\&quot;}]&quot;
def String str = &quot;&quot;;


def String str1 = &quot;[&quot;;

def String str2 = &quot;&quot;;

def String tempStr = &quot;&quot;;

// we are taking i as group number and j as the tag number of that particular group:
// earlier, we had a req of 1000 tabs per each of 100 groups:

// for the new perf of TS, we need only 1 group and 300 tags.

//for(long i =91;i&lt;=100;++i){

//for(long i =1;i&lt;=50;++i){	

// there is an issue[?]/CTQ where we can only create 50 tags at a time in a create call tag

//int startCountGroupLocal = ${startGroupCount};
//int stopCountGroupLocal = startCountGroupLocal+4;



for(long i =${startGroupCount};i&lt;=${startGroupCount}+4;++i){	
	
log.info(&quot;***value i ***\n&quot;);
log.info(String.valueOf(i));
	
//for(long j = 1;j&lt;=1000;++j){

for(long j = 1;j&lt;=300;++j){
log.info(&quot;+++++++%%%%%%%%+&quot;+String.valueOf(${startGroupCount})+&quot;++++++++++++++++++&quot;);
log.info(&quot;+++++++%%%%%%%%+&quot;+String.valueOf(${startGroupCount}+4)+&quot;++++++++++++++++++&quot;);
	log.info(&quot;***value j ***\n&quot;);
	log.info(String.valueOf(j));
log.info(&quot;+++++++%%%%%%%%+&quot;+String.valueOf(${startGroupCount})+&quot;++++++++++++++++++&quot;);
log.info(&quot;+++++++%%%%%%%%+&quot;+String.valueOf(${startGroupCount}+4)+&quot;++++++++++++++++++&quot;);

//tempStr = &quot;{\&quot;Id\&quot;:\&quot;July15_PI_Digital_&quot;+j+&quot;\&quot;,\&quot;Name\&quot;:\&quot;July15_PI_Digital_&quot;+j+&quot;\&quot;,\&quot;Description\&quot;:\&quot;AmbientPressure\&quot;,\&quot;GroupId\&quot;:\&quot;S1E2C-PROTO4\&quot;,\&quot;CollectionType\&quot;:\&quot;Offline\&quot;,\&quot;DataType\&quot;:\&quot;Digital\&quot;,\&quot;StorageClass\&quot;:[\&quot;Raw\&quot;,\&quot;Tiered\&quot;],\&quot;Unit\&quot;:null,\&quot;SubUnit\&quot;:null,\&quot;DataSourceType\&quot;:\&quot;PI\&quot;},&quot;;

//tempStr = &quot;{\&quot;Id\&quot;:\&quot;qaTestNoPIDataInt32_&quot;+j+&quot;\&quot;,\&quot;Name\&quot;:\&quot;qaTestNoPIDataInt32_&quot;+j+&quot;\&quot;,\&quot;Description\&quot;:\&quot;AmbientPressure\&quot;,\&quot;GroupId\&quot;:\&quot;S1E2C-PROTO4\&quot;,\&quot;CollectionType\&quot;:\&quot;Offline\&quot;,\&quot;DataType\&quot;:\&quot;Int32\&quot;,\&quot;StorageClass\&quot;:[\&quot;Raw\&quot;,\&quot;Tiered\&quot;],\&quot;Unit\&quot;:null,\&quot;SubUnit\&quot;:null,\&quot;DataSourceType\&quot;:\&quot;PI\&quot;},&quot;;


//tempStr=&quot;{\&quot;id\&quot;:\&quot;Online_TagNov23_&quot;+j+&quot;\&quot;,\&quot;Name\&quot;:\&quot;Online_TagNov23_&quot;+j+&quot;\&quot;,\&quot;Description\&quot;:\&quot;Online_TagNov23_&quot;+j+&quot;\&quot;,\&quot;GroupId\&quot;:\&quot;Online_Tag_Nov23\&quot;,\&quot;ParentTagId\&quot;:\&quot;Online_TagNov23_&quot;+j+&quot;_Parent\&quot;,\&quot;DataType\&quot;:\&quot;Float16\&quot;,\&quot;StorageClass\&quot;:[\&quot;Raw\&quot;,\&quot;Tiered\&quot;],\&quot;Unit\&quot;:\&quot;ml\&quot;,\&quot;SubUnit\&quot;:\&quot;pp\&quot;,\&quot;DataSourceType\&quot;:\&quot;PGstore\&quot;,\&quot;DataSourceProperties\&quot;:{\&quot;ExchangeType\&quot;:\&quot;Header\&quot;,\&quot;QueueName\&quot;:\&quot;6f5d144b\&quot;},\&quot;CollectionType\&quot;:\&quot;Online\&quot;,\&quot;CustomAttributes\&quot;:{\&quot;Location\&quot;:\&quot;Unit02-CompressorEnd\&quot;,\&quot;SensorType\&quot;:\&quot;MagneticDisplacement\&quot;}},{\&quot;id\&quot;:\&quot;Online_TagNov23_&quot;+j+&quot;_Parent\&quot;,\&quot;Name\&quot;:\&quot;Online_TagNov23_&quot;+j+&quot;_Parent\&quot;,\&quot;Description\&quot;:\&quot;Online_TagNov23_&quot;+j+&quot;_Parent\&quot;,\&quot;GroupId\&quot;:\&quot;Online_Tag_Nov23\&quot;,\&quot;ParentTagId\&quot;:\&quot;\&quot;,\&quot;DataType\&quot;:\&quot;Float16\&quot;,\&quot;StorageClass\&quot;:[\&quot;Raw\&quot;,\&quot;Tiered\&quot;],\&quot;Unit\&quot;:\&quot;ml\&quot;,\&quot;SubUnit\&quot;:\&quot;pp\&quot;,\&quot;DataSourceType\&quot;:\&quot;PGstore\&quot;,\&quot;DataSourceProperties\&quot;:{\&quot;ExchangeType\&quot;:\&quot;Header\&quot;,\&quot;QueueName\&quot;:\&quot;6f5d144b\&quot;},\&quot;CollectionType\&quot;:\&quot;Online\&quot;,\&quot;CustomAttributes\&quot;:{\&quot;Location\&quot;:\&quot;Unit02-CompressorEnd\&quot;,\&quot;SensorType\&quot;:\&quot;MagneticDisplacement\&quot;}},&quot;

//SELECT pg_size_pretty( pg_database_size(&apos;1146ddfb-fe47-4aac-b564-7f80b31008de_timeseries&apos;) );

//ONLINE TAGS LONGEVITY: CREATE STR BODY:

//tempStr=&quot;{\&quot;id\&quot;:\&quot;OnlineTagLong_&quot;+j+&quot;_G_&quot;+i+&quot;\&quot;,\&quot;Name\&quot;:\&quot;OnlineTagLong_&quot;+j+&quot;_G_&quot;+i+&quot;\&quot;,\&quot;Description\&quot;:\&quot;OnlineTagLong_&quot;+j+&quot;_G_&quot;+i+&quot;\&quot;,\&quot;GroupId\&quot;:\&quot;Group_OnlineTagLong_&quot;+i+&quot;\&quot;,\&quot;DataType\&quot;:\&quot;Float16\&quot;,\&quot;StorageClass\&quot;:[\&quot;Raw\&quot;,\&quot;Tiered\&quot;],\&quot;Unit\&quot;:\&quot;ml\&quot;,\&quot;SubUnit\&quot;:\&quot;pp\&quot;,\&quot;DataSourceType\&quot;:\&quot;PGstore\&quot;,\&quot;DataSourceProperties\&quot;:{\&quot;ExchangeType\&quot;:\&quot;Header\&quot;,\&quot;QueueName\&quot;:\&quot;6f5d144b\&quot;},\&quot;CollectionType\&quot;:\&quot;Online\&quot;,\&quot;CustomAttributes\&quot;:{\&quot;Location\&quot;:\&quot;Unit02-CompressorEnd\&quot;,\&quot;SensorType\&quot;:\&quot;MagneticDisplacement\&quot;}},&quot;

//OFFLINE TAGS LONGEVITY: CREATE STR BODY:

tempStr=&quot;{\&quot;id\&quot;:\&quot;RelTestPERF_AWS_5APR23_OfflineTag_&quot;+j+&quot;_G_&quot;+i+&quot;\&quot;,\&quot;Name\&quot;:\&quot;RelTestPERF_AWS_5APR23_OfflineTag_&quot;+j+&quot;_G_&quot;+i+&quot;\&quot;,\&quot;Description\&quot;:\&quot;RelTestPERF_AWS_5APR23_OfflineTag_&quot;+j+&quot;_G_&quot;+i+&quot;\&quot;,\&quot;GroupId\&quot;:\&quot;RelTestPERF_AWS_5APR23_OfflineTag_&quot;+i+&quot;\&quot;,\&quot;DataType\&quot;:\&quot;Float16\&quot;,\&quot;StorageClass\&quot;:[\&quot;Raw\&quot;,\&quot;Tiered\&quot;],\&quot;Unit\&quot;:\&quot;ml\&quot;,\&quot;SubUnit\&quot;:\&quot;pp\&quot;,\&quot;DataSourceType\&quot;:\&quot;PGstore\&quot;,\&quot;DataSourceProperties\&quot;:{\&quot;ExchangeType\&quot;:\&quot;Header\&quot;,\&quot;QueueName\&quot;:\&quot;6f5d144b\&quot;},\&quot;CollectionType\&quot;:\&quot;Offline\&quot;,\&quot;CustomAttributes\&quot;:{\&quot;Location\&quot;:\&quot;Unit02-CompressorEnd\&quot;,\&quot;SensorType\&quot;:\&quot;MagneticDisplacement\&quot;}},&quot;

str2 = str2+tempStr;

}

}

def String str3 = &quot;]&quot;;

str = str1+str2+str3;


//str=&quot;[{\&quot;Id\&quot;:\&quot;July15_PI_Int32_&quot;+j+&quot;\&quot;,\&quot;Name\&quot;:\&quot;July15_PI_Int32_&quot;+j+&quot;\&quot;,\&quot;Description\&quot;:\&quot;AmbientPressure\&quot;,\&quot;GroupId\&quot;:\&quot;S1E2C-PROTO4\&quot;,\&quot;CollectionType\&quot;:\&quot;Offline\&quot;,\&quot;DataType\&quot;:\&quot;Int32\&quot;,\&quot;StorageClass\&quot;:[\&quot;Raw\&quot;,\&quot;Tiered\&quot;],\&quot;Unit\&quot;:null,\&quot;SubUnit\&quot;:null,\&quot;DataSourceType\&quot;:\&quot;PI\&quot;}]&quot;
	
	//def parser = new JsonSlurper()
	//def json = parser.parseText(str)
	
	//vars.put(&quot;Payload&quot;, PayloadJson)
	//vars.put(&quot;Payload&quot;, json)
	//log.info(&quot;************* JSON SLURPER  ********************* &quot;+vars.get(&quot;Payload&quot;))
	
	vars.put(&quot;Payload&quot;, str)

//	log.info(&quot;************* Create Tag ********************* &quot;+vars.get(&quot;Payload&quot;))
//
//
//	        log.info(&quot;#########################################&quot;);
//            log.info(&quot;IP of system is := &quot; + ip.getHostAddress());
//            logger.info(&quot;IP of system is := &quot; + ip.getHostAddress());
//           log.info(&quot;#########################################&quot;);

//}
	
	//println &quot;************* create tag ********************* &quot;+vars.get(&quot;Payload&quot;)
//	log.info(&quot;************* Set Data ********************* &quot;+vars.get(&quot;Payload&quot;))
	
	//println &quot;************* create tag ********************* &quot;+vars.get(&quot;Payload&quot;)
	//log.info(&quot;************* Set Data ********************* &quot;+vars.get(&quot;Payload&quot;))
//}
</stringProp>
          </JSR223PreProcessor>
          <hashTree/>
          <HeaderManager guiclass="HeaderPanel" testclass="HeaderManager" testname="HTTP Header Manager" enabled="true">
            <collectionProp name="HeaderManager.headers">
              <elementProp name="" elementType="Header">
                <stringProp name="Header.name">tenantID</stringProp>
                <stringProp name="Header.value">${tenant}</stringProp>
              </elementProp>
              <elementProp name="" elementType="Header">
                <stringProp name="Header.name">Content-Type</stringProp>
                <stringProp name="Header.value">application/json</stringProp>
              </elementProp>
              <elementProp name="" elementType="Header">
                <stringProp name="Header.name">Authorization</stringProp>
                <stringProp name="Header.value">Bearer ${__property(token)}</stringProp>
              </elementProp>
            </collectionProp>
          </HeaderManager>
          <hashTree/>
          <ResponseAssertion guiclass="AssertionGui" testclass="ResponseAssertion" testname="Response Assertion" enabled="true">
            <collectionProp name="Asserion.test_strings">
              <stringProp name="49587">201</stringProp>
            </collectionProp>
            <stringProp name="Assertion.custom_message"></stringProp>
            <stringProp name="Assertion.test_field">Assertion.response_code</stringProp>
            <boolProp name="Assertion.assume_success">false</boolProp>
            <intProp name="Assertion.test_type">8</intProp>
          </ResponseAssertion>
          <hashTree/>
          <ResultCollector guiclass="ViewResultsFullVisualizer" testclass="ResultCollector" testname="View Results Tree" enabled="false">
            <boolProp name="ResultCollector.error_logging">false</boolProp>
            <objProp>
              <name>saveConfig</name>
              <value class="SampleSaveConfiguration">
                <time>true</time>
                <latency>true</latency>
                <timestamp>true</timestamp>
                <success>true</success>
                <label>true</label>
                <code>true</code>
                <message>true</message>
                <threadName>true</threadName>
                <dataType>true</dataType>
                <encoding>false</encoding>
                <assertions>true</assertions>
                <subresults>true</subresults>
                <responseData>false</responseData>
                <samplerData>false</samplerData>
                <xml>false</xml>
                <fieldNames>true</fieldNames>
                <responseHeaders>false</responseHeaders>
                <requestHeaders>false</requestHeaders>
                <responseDataOnError>false</responseDataOnError>
                <saveAssertionResultsFailureMessage>true</saveAssertionResultsFailureMessage>
                <assertionsResultsToSave>0</assertionsResultsToSave>
                <bytes>true</bytes>
                <sentBytes>true</sentBytes>
                <url>true</url>
                <threadCounts>true</threadCounts>
                <idleTime>true</idleTime>
                <connectTime>true</connectTime>
              </value>
            </objProp>
            <stringProp name="filename"></stringProp>
          </ResultCollector>
          <hashTree/>
          <ResultCollector guiclass="SummaryReport" testclass="ResultCollector" testname="Summary Report" enabled="false">
            <boolProp name="ResultCollector.error_logging">false</boolProp>
            <objProp>
              <name>saveConfig</name>
              <value class="SampleSaveConfiguration">
                <time>true</time>
                <latency>true</latency>
                <timestamp>true</timestamp>
                <success>true</success>
                <label>true</label>
                <code>true</code>
                <message>true</message>
                <threadName>true</threadName>
                <dataType>true</dataType>
                <encoding>false</encoding>
                <assertions>true</assertions>
                <subresults>true</subresults>
                <responseData>false</responseData>
                <samplerData>false</samplerData>
                <xml>false</xml>
                <fieldNames>true</fieldNames>
                <responseHeaders>false</responseHeaders>
                <requestHeaders>false</requestHeaders>
                <responseDataOnError>false</responseDataOnError>
                <saveAssertionResultsFailureMessage>true</saveAssertionResultsFailureMessage>
                <assertionsResultsToSave>0</assertionsResultsToSave>
                <bytes>true</bytes>
                <sentBytes>true</sentBytes>
                <url>true</url>
                <threadCounts>true</threadCounts>
                <idleTime>true</idleTime>
                <connectTime>true</connectTime>
              </value>
            </objProp>
            <stringProp name="filename"></stringProp>
          </ResultCollector>
          <hashTree/>
          <ResultCollector guiclass="StatVisualizer" testclass="ResultCollector" testname="Aggregate Report" enabled="false">
            <boolProp name="ResultCollector.error_logging">false</boolProp>
            <objProp>
              <name>saveConfig</name>
              <value class="SampleSaveConfiguration">
                <time>true</time>
                <latency>true</latency>
                <timestamp>true</timestamp>
                <success>true</success>
                <label>true</label>
                <code>true</code>
                <message>true</message>
                <threadName>true</threadName>
                <dataType>true</dataType>
                <encoding>false</encoding>
                <assertions>true</assertions>
                <subresults>true</subresults>
                <responseData>false</responseData>
                <samplerData>false</samplerData>
                <xml>false</xml>
                <fieldNames>true</fieldNames>
                <responseHeaders>false</responseHeaders>
                <requestHeaders>false</requestHeaders>
                <responseDataOnError>false</responseDataOnError>
                <saveAssertionResultsFailureMessage>true</saveAssertionResultsFailureMessage>
                <assertionsResultsToSave>0</assertionsResultsToSave>
                <bytes>true</bytes>
                <sentBytes>true</sentBytes>
                <url>true</url>
                <threadCounts>true</threadCounts>
                <idleTime>true</idleTime>
                <connectTime>true</connectTime>
              </value>
            </objProp>
            <stringProp name="filename"></stringProp>
          </ResultCollector>
          <hashTree/>
          <ResultCollector guiclass="TableVisualizer" testclass="ResultCollector" testname="View Results in Table" enabled="false">
            <boolProp name="ResultCollector.error_logging">false</boolProp>
            <objProp>
              <name>saveConfig</name>
              <value class="SampleSaveConfiguration">
                <time>true</time>
                <latency>true</latency>
                <timestamp>true</timestamp>
                <success>true</success>
                <label>true</label>
                <code>true</code>
                <message>true</message>
                <threadName>true</threadName>
                <dataType>true</dataType>
                <encoding>false</encoding>
                <assertions>true</assertions>
                <subresults>true</subresults>
                <responseData>false</responseData>
                <samplerData>false</samplerData>
                <xml>false</xml>
                <fieldNames>true</fieldNames>
                <responseHeaders>false</responseHeaders>
                <requestHeaders>false</requestHeaders>
                <responseDataOnError>false</responseDataOnError>
                <saveAssertionResultsFailureMessage>true</saveAssertionResultsFailureMessage>
                <assertionsResultsToSave>0</assertionsResultsToSave>
                <bytes>true</bytes>
                <sentBytes>true</sentBytes>
                <url>true</url>
                <threadCounts>true</threadCounts>
                <idleTime>true</idleTime>
                <connectTime>true</connectTime>
              </value>
            </objProp>
            <stringProp name="filename"></stringProp>
          </ResultCollector>
          <hashTree/>
        </hashTree>
        <JSR223Sampler guiclass="TestBeanGUI" testclass="JSR223Sampler" testname="Create PG Tag Api Body" enabled="false">
          <stringProp name="cacheKey">false</stringProp>
          <stringProp name="filename"></stringProp>
          <stringProp name="parameters"></stringProp>
          <stringProp name="script">import groovy.json.*
import java.util.GregorianCalendar;
import java.util.Calendar;
import java.util.Date;
import java.net.InetAddress;
import org.slf4j.Logger;
import org.slf4j.LoggerFactory;

// VERY VERY IMP: REMOVE/UNCHECK CACHE COMPILED SCRIPT ABOVE OPTION ELSE COUNTER WONT WORK

ip = InetAddress.getLocalHost();
Logger logger = LoggerFactory.getLogger(&quot;IPLogger&quot;);
log.info(&quot;#########################################&quot;);
log.info(&quot;IP of system is := &quot; + ip.getHostAddress());
logger.info(&quot;IP of system is := &quot; + ip.getHostAddress());
log.info(&quot;#########################################&quot;);

def String createTagApiBody = &quot;&quot;;
def String createCombTagStr = &quot;&quot;;
def String oneTagStr = &quot;&quot;;

// [solved by counter:] there is an issue[?]/CTQ where we can only create 5 groups tags [5*300=1500 tags] at a time in a create call tag

for(long i =${startGroupCount};i&lt;=${startGroupCount}+4;++i){	
	
log.info(&quot;***value i ***&quot;);
log.info(String.valueOf(i));
	
for(long j = 1;j&lt;=300;++j){
	
log.info(&quot;+++++++%%%%%%%%+&quot;+String.valueOf(${startGroupCount})+&quot;++++++++++++++++++&quot;);
log.info(&quot;+++++++%%%%%%%%+&quot;+String.valueOf(${startGroupCount}+4)+&quot;++++++++++++++++++&quot;);
log.info(&quot;***value j ***&quot;);
log.info(String.valueOf(j));

log.info(&quot;***value i ***&quot;);
log.info(String.valueOf(i));


oneTagStr=&quot;{\&quot;id\&quot;:\&quot;RelTestPERF_AWS_5APR23_OfflineTag_&quot;+j+&quot;_G_&quot;+i+&quot;\&quot;,\&quot;Name\&quot;:\&quot;RelTestPERF_AWS_5APR23_OfflineTag_&quot;+j+&quot;_G_&quot;+i+&quot;\&quot;,\&quot;Description\&quot;:\&quot;RelTestPERF_AWS_5APR23_OfflineTag_&quot;+j+&quot;_G_&quot;+i+&quot;\&quot;,\&quot;GroupId\&quot;:\&quot;RelTestPERF_AWS_5APR23_OfflineTag_&quot;+i+&quot;\&quot;,\&quot;DataType\&quot;:\&quot;Float16\&quot;,\&quot;StorageClass\&quot;:[\&quot;Raw\&quot;,\&quot;Tiered\&quot;],\&quot;Unit\&quot;:\&quot;ml\&quot;,\&quot;SubUnit\&quot;:\&quot;pp\&quot;,\&quot;DataSourceType\&quot;:\&quot;PGstore\&quot;,\&quot;DataSourceProperties\&quot;:{\&quot;ExchangeType\&quot;:\&quot;Header\&quot;,\&quot;QueueName\&quot;:\&quot;6f5d144b\&quot;},\&quot;CollectionType\&quot;:\&quot;Offline\&quot;,\&quot;CustomAttributes\&quot;:{\&quot;Location\&quot;:\&quot;Unit02-CompressorEnd\&quot;,\&quot;SensorType\&quot;:\&quot;MagneticDisplacement\&quot;}},&quot;

createCombTagStr = createCombTagStr+oneTagStr;

}

}

createTagApiBody = &quot;[&quot;+createCombTagStr+&quot;]&quot;;
	
vars.put(&quot;Payload_CreatePgTag&quot;, createTagApiBody)

log.info(&quot;Value Of Counter:&quot;);
log.info(String.valueOf(${startGroupCount}));

log.info(&quot;Value Of LoopController:&quot;);
log.info(String.valueOf(${__jm__LoopController__idx}));


</stringProp>
          <stringProp name="scriptLanguage">groovy</stringProp>
        </JSR223Sampler>
        <hashTree/>
        <LoopController guiclass="LoopControlPanel" testclass="LoopController" testname="CreateTagsByGroupNumLoop" enabled="false">
          <boolProp name="LoopController.continue_forever">true</boolProp>
          <stringProp name="LoopController.loops">5</stringProp>
        </LoopController>
        <hashTree>
          <HTTPSamplerProxy guiclass="HttpTestSampleGui" testclass="HTTPSamplerProxy" testname="GenerateTenantToken" enabled="true">
            <elementProp name="HTTPsampler.Arguments" elementType="Arguments" guiclass="HTTPArgumentsPanel" testclass="Arguments" testname="User Defined Variables" enabled="true">
              <collectionProp name="Arguments.arguments">
                <elementProp name="username" elementType="HTTPArgument">
                  <boolProp name="HTTPArgument.always_encode">false</boolProp>
                  <stringProp name="Argument.value">s1e-realm-admin</stringProp>
                  <stringProp name="Argument.metadata">=</stringProp>
                  <boolProp name="HTTPArgument.use_equals">true</boolProp>
                  <stringProp name="Argument.name">username</stringProp>
                </elementProp>
                <elementProp name="password" elementType="HTTPArgument">
                  <boolProp name="HTTPArgument.always_encode">false</boolProp>
                  <stringProp name="Argument.value">Test@123</stringProp>
                  <stringProp name="Argument.metadata">=</stringProp>
                  <boolProp name="HTTPArgument.use_equals">true</boolProp>
                  <stringProp name="Argument.name">password</stringProp>
                </elementProp>
                <elementProp name="client_id" elementType="HTTPArgument">
                  <boolProp name="HTTPArgument.always_encode">false</boolProp>
                  <stringProp name="Argument.value">app-appshell</stringProp>
                  <stringProp name="Argument.metadata">=</stringProp>
                  <boolProp name="HTTPArgument.use_equals">true</boolProp>
                  <stringProp name="Argument.name">client_id</stringProp>
                </elementProp>
                <elementProp name="grant_type" elementType="HTTPArgument">
                  <boolProp name="HTTPArgument.always_encode">false</boolProp>
                  <stringProp name="Argument.value">password</stringProp>
                  <stringProp name="Argument.metadata">=</stringProp>
                  <boolProp name="HTTPArgument.use_equals">true</boolProp>
                  <stringProp name="Argument.name">grant_type</stringProp>
                </elementProp>
                <elementProp name="client_secret" elementType="HTTPArgument">
                  <boolProp name="HTTPArgument.always_encode">false</boolProp>
                  <stringProp name="Argument.value">${client_secret}</stringProp>
                  <stringProp name="Argument.metadata">=</stringProp>
                  <boolProp name="HTTPArgument.use_equals">true</boolProp>
                  <stringProp name="Argument.name">client_secret</stringProp>
                </elementProp>
              </collectionProp>
            </elementProp>
            <stringProp name="HTTPSampler.domain">${AuthURL}</stringProp>
            <stringProp name="HTTPSampler.port"></stringProp>
            <stringProp name="HTTPSampler.protocol">https</stringProp>
            <stringProp name="HTTPSampler.contentEncoding"></stringProp>
            <stringProp name="HTTPSampler.path">/auth/realms/${Tenant_Id}/protocol/openid-connect/token</stringProp>
            <stringProp name="HTTPSampler.method">POST</stringProp>
            <boolProp name="HTTPSampler.follow_redirects">true</boolProp>
            <boolProp name="HTTPSampler.auto_redirects">false</boolProp>
            <boolProp name="HTTPSampler.use_keepalive">true</boolProp>
            <boolProp name="HTTPSampler.DO_MULTIPART_POST">false</boolProp>
            <stringProp name="HTTPSampler.embedded_url_re"></stringProp>
            <stringProp name="HTTPSampler.connect_timeout"></stringProp>
            <stringProp name="HTTPSampler.response_timeout"></stringProp>
          </HTTPSamplerProxy>
          <hashTree>
            <SyncTimer guiclass="TestBeanGUI" testclass="SyncTimer" testname="Synchronizing Timer" enabled="true">
              <intProp name="groupSize">1</intProp>
              <longProp name="timeoutInMs">0</longProp>
            </SyncTimer>
            <hashTree/>
            <HeaderManager guiclass="HeaderPanel" testclass="HeaderManager" testname="HTTP Header Manager" enabled="true">
              <collectionProp name="HeaderManager.headers">
                <elementProp name="" elementType="Header">
                  <stringProp name="Header.name">Content-Type</stringProp>
                  <stringProp name="Header.value">application/x-www-form-urlencoded</stringProp>
                </elementProp>
              </collectionProp>
            </HeaderManager>
            <hashTree/>
            <JSONPostProcessor guiclass="JSONPostProcessorGui" testclass="JSONPostProcessor" testname="JSON Extractor" enabled="true">
              <stringProp name="JSONPostProcessor.referenceNames">token</stringProp>
              <stringProp name="JSONPostProcessor.jsonPathExprs">access_token</stringProp>
              <stringProp name="JSONPostProcessor.match_numbers"></stringProp>
            </JSONPostProcessor>
            <hashTree/>
            <BeanShellAssertion guiclass="BeanShellAssertionGui" testclass="BeanShellAssertion" testname="BeanShell Assertion" enabled="true">
              <stringProp name="BeanShellAssertion.query">${__setProperty(token, ${token})};</stringProp>
              <stringProp name="BeanShellAssertion.filename"></stringProp>
              <stringProp name="BeanShellAssertion.parameters"></stringProp>
              <boolProp name="BeanShellAssertion.resetInterpreter">false</boolProp>
            </BeanShellAssertion>
            <hashTree/>
          </hashTree>
          <JSR223Sampler guiclass="TestBeanGUI" testclass="JSR223Sampler" testname="Create PG Tag Api Body" enabled="true">
            <stringProp name="cacheKey">false</stringProp>
            <stringProp name="filename"></stringProp>
            <stringProp name="parameters"></stringProp>
            <stringProp name="script">import groovy.json.*
import java.util.GregorianCalendar;
import java.util.Calendar;
import java.util.Date;
import java.net.InetAddress;
import org.slf4j.Logger;
import org.slf4j.LoggerFactory;

// VERY VERY IMP: REMOVE/UNCHECK CACHE COMPILED SCRIPT ABOVE OPTION ELSE COUNTER WONT WORK


def String createTagApiBody = &quot;&quot;;
def String createCombTagStr = &quot;&quot;;
def String oneTagStr = &quot;&quot;;

// INSERT THE NUMBER OF GROUPS IN THE LOOP COUNT

def groupNum = ${__BeanShell(vars.getIteration();,)}
	
for(long tagNum = 1;tagNum&lt;=300;++tagNum){


oneTagStr=&quot;{\&quot;id\&quot;:\&quot;PerfTag_G_&quot;+groupNum+&quot;_T_&quot;+tagNum+&quot;\&quot;,\&quot;Name\&quot;:\&quot;PerfTag_G_&quot;+groupNum+&quot;_T_&quot;+tagNum+&quot;\&quot;,\&quot;Description\&quot;:\&quot;PerfTag_G_&quot;+groupNum+&quot;_T_&quot;+tagNum+&quot;\&quot;,\&quot;GroupId\&quot;:\&quot;PerfTag_G_&quot;+groupNum+&quot;\&quot;,\&quot;DataType\&quot;:\&quot;Float16\&quot;,\&quot;StorageClass\&quot;:[\&quot;Raw\&quot;,\&quot;Tiered\&quot;],\&quot;Unit\&quot;:\&quot;ml\&quot;,\&quot;SubUnit\&quot;:\&quot;pp\&quot;,\&quot;DataSourceType\&quot;:\&quot;PGstore\&quot;,\&quot;DataSourceProperties\&quot;:{\&quot;ExchangeType\&quot;:\&quot;Header\&quot;,\&quot;QueueName\&quot;:\&quot;6f5d144b\&quot;},\&quot;CollectionType\&quot;:\&quot;Offline\&quot;,\&quot;CustomAttributes\&quot;:{\&quot;Location\&quot;:\&quot;Unit02-CompressorEnd\&quot;,\&quot;SensorType\&quot;:\&quot;MagneticDisplacement\&quot;}},&quot;

createCombTagStr = createCombTagStr+oneTagStr;

}


createTagApiBody = &quot;[&quot;+createCombTagStr+&quot;]&quot;;
	
vars.put(&quot;Payload_CreatePgTag&quot;, createTagApiBody)


log.info(&quot;Body of Create:&quot;);
log.info(String.valueOf(vars.get(&quot;Payload_CreatePgTag&quot;)));</stringProp>
            <stringProp name="scriptLanguage">groovy</stringProp>
          </JSR223Sampler>
          <hashTree/>
          <HTTPSamplerProxy guiclass="HttpTestSampleGui" testclass="HTTPSamplerProxy" testname="CreateNewTagRequest" enabled="true">
            <boolProp name="HTTPSampler.postBodyRaw">true</boolProp>
            <elementProp name="HTTPsampler.Arguments" elementType="Arguments">
              <collectionProp name="Arguments.arguments">
                <elementProp name="" elementType="HTTPArgument">
                  <boolProp name="HTTPArgument.always_encode">false</boolProp>
                  <stringProp name="Argument.value">${Payload_CreatePgTag}</stringProp>
                  <stringProp name="Argument.metadata">=</stringProp>
                </elementProp>
              </collectionProp>
            </elementProp>
            <stringProp name="HTTPSampler.domain">perf.np-0000197.npause1.bakerhughes.com</stringProp>
            <stringProp name="HTTPSampler.port"></stringProp>
            <stringProp name="HTTPSampler.protocol">https</stringProp>
            <stringProp name="HTTPSampler.contentEncoding"></stringProp>
            <stringProp name="HTTPSampler.path">timeseries/v1/tags</stringProp>
            <stringProp name="HTTPSampler.method">POST</stringProp>
            <boolProp name="HTTPSampler.follow_redirects">true</boolProp>
            <boolProp name="HTTPSampler.auto_redirects">false</boolProp>
            <boolProp name="HTTPSampler.use_keepalive">true</boolProp>
            <boolProp name="HTTPSampler.DO_MULTIPART_POST">false</boolProp>
            <stringProp name="HTTPSampler.embedded_url_re"></stringProp>
            <stringProp name="HTTPSampler.connect_timeout"></stringProp>
            <stringProp name="HTTPSampler.response_timeout"></stringProp>
          </HTTPSamplerProxy>
          <hashTree>
            <HeaderManager guiclass="HeaderPanel" testclass="HeaderManager" testname="HTTP Header Manager" enabled="true">
              <collectionProp name="HeaderManager.headers">
                <elementProp name="" elementType="Header">
                  <stringProp name="Header.name">tenantID</stringProp>
                  <stringProp name="Header.value">${tenant}</stringProp>
                </elementProp>
                <elementProp name="" elementType="Header">
                  <stringProp name="Header.name">Content-Type</stringProp>
                  <stringProp name="Header.value">application/json</stringProp>
                </elementProp>
                <elementProp name="" elementType="Header">
                  <stringProp name="Header.name">Authorization</stringProp>
                  <stringProp name="Header.value">Bearer ${__property(token)}</stringProp>
                </elementProp>
              </collectionProp>
            </HeaderManager>
            <hashTree/>
            <ResponseAssertion guiclass="AssertionGui" testclass="ResponseAssertion" testname="Response Assertion" enabled="true">
              <collectionProp name="Asserion.test_strings">
                <stringProp name="49587">201</stringProp>
              </collectionProp>
              <stringProp name="Assertion.custom_message"></stringProp>
              <stringProp name="Assertion.test_field">Assertion.response_code</stringProp>
              <boolProp name="Assertion.assume_success">false</boolProp>
              <intProp name="Assertion.test_type">8</intProp>
            </ResponseAssertion>
            <hashTree/>
          </hashTree>
        </hashTree>
      </hashTree>
      <ResultCollector guiclass="ViewResultsFullVisualizer" testclass="ResultCollector" testname="View All Results Tree" enabled="true">
        <boolProp name="ResultCollector.error_logging">false</boolProp>
        <objProp>
          <name>saveConfig</name>
          <value class="SampleSaveConfiguration">
            <time>true</time>
            <latency>true</latency>
            <timestamp>true</timestamp>
            <success>true</success>
            <label>true</label>
            <code>true</code>
            <message>true</message>
            <threadName>true</threadName>
            <dataType>true</dataType>
            <encoding>false</encoding>
            <assertions>true</assertions>
            <subresults>true</subresults>
            <responseData>false</responseData>
            <samplerData>false</samplerData>
            <xml>false</xml>
            <fieldNames>true</fieldNames>
            <responseHeaders>false</responseHeaders>
            <requestHeaders>false</requestHeaders>
            <responseDataOnError>false</responseDataOnError>
            <saveAssertionResultsFailureMessage>true</saveAssertionResultsFailureMessage>
            <assertionsResultsToSave>0</assertionsResultsToSave>
            <bytes>true</bytes>
            <sentBytes>true</sentBytes>
            <url>true</url>
            <threadCounts>true</threadCounts>
            <idleTime>true</idleTime>
            <connectTime>true</connectTime>
          </value>
        </objProp>
        <stringProp name="filename"></stringProp>
      </ResultCollector>
      <hashTree/>
      <ResultCollector guiclass="ViewResultsFullVisualizer" testclass="ResultCollector" testname="View Error Results Tree" enabled="true">
        <boolProp name="ResultCollector.error_logging">true</boolProp>
        <objProp>
          <name>saveConfig</name>
          <value class="SampleSaveConfiguration">
            <time>true</time>
            <latency>true</latency>
            <timestamp>true</timestamp>
            <success>true</success>
            <label>true</label>
            <code>true</code>
            <message>true</message>
            <threadName>true</threadName>
            <dataType>true</dataType>
            <encoding>false</encoding>
            <assertions>true</assertions>
            <subresults>true</subresults>
            <responseData>false</responseData>
            <samplerData>false</samplerData>
            <xml>false</xml>
            <fieldNames>true</fieldNames>
            <responseHeaders>false</responseHeaders>
            <requestHeaders>false</requestHeaders>
            <responseDataOnError>false</responseDataOnError>
            <saveAssertionResultsFailureMessage>true</saveAssertionResultsFailureMessage>
            <assertionsResultsToSave>0</assertionsResultsToSave>
            <bytes>true</bytes>
            <sentBytes>true</sentBytes>
            <url>true</url>
            <threadCounts>true</threadCounts>
            <idleTime>true</idleTime>
            <connectTime>true</connectTime>
          </value>
        </objProp>
        <stringProp name="filename"></stringProp>
      </ResultCollector>
      <hashTree/>
    </hashTree>
  </hashTree>
</jmeterTestPlan>
